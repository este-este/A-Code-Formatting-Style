---
#` clang-format file for the "A-Code-Formatting-Style" (ACFS) guidelines.  See https://github.com/este-este/A-Code-Formatting-Style
#
# *******************************************************************************
# Date:      2025-03-28
# Filename:  este-este_v1.04.clang-format
# Author:    este este (https://github.com/este-este)
#
#   Note:  You must rename this file to ".clang-format" to have it be recognized by the clang-format executable.
#
#
# Background:
#
#   Clang-format is part of the LLVM project (https://llvm.org/).  All LLVM releases are at https://github.com/llvm/llvm-project/releases
#     - As of this writing:
#         - The current version of LLVM is v19.1.7 but only v19.1.6 has released binaries (see https://github.com/llvm/llvm-project/releases/tag/llvmorg-19.1.6)
#             so it is clang-format v19.1.6 that was tested.
#             - To get current versions of clang-format, you must install LLVM first.  In Windows, the clang-format.exe file is at C:\Program Files\LLVM\bin\.
#                 You can move clang-format.exe to another location and then uninstall LLVM to save disk space if desired.
#         - The current version for clang-format documentation is v21.0 (https://clang.llvm.org/docs/ClangFormatStyleOptions.html) but only the Options
#             up to v19 are targeted by this .clang-format file.
#         - Some errors were found in the current documentation.  
#             - Where completely incorrect, I have included the incorrect version, tagged with "This is actually incorrect.", and then followed
#                 the entry with the correct version (as of this writing of course!).  
#             - Where partly incorrect, I have annotated what is incorrect in that entry.
#
#   The brace indentation is an important part of all code formatting styles.  I recommend you review of brace indentation styles at https://en.wikipedia.org/wiki/Indentation_style
#     since the following styles are referenced:  Allman, GNU, K&R, Stroustrup, Whitesmiths, and One-True-Brace.
#
#
# Clang-format & ACFS Guidelines:
#
#   This clang-format file is a close but not a perfect match to the ACFS guidelines.
#     Below are some limitations and workarounds.  Recommendations are indicated by ">>>>>>"
#       (Note that I have used the "!_NOTE_!" keyword in the Alphabetical Listing Section for options that
#        are important to implement the ACFS guidelines).
#
#     - Multi-line conditional expression parentheses are formatted K&R style, not an indented Allman style.
#         - You can force a non-indented Allman style by placing an in-line comment after the conditional keyword.  
#             - However, the parentheses will not be indented but will instead be aligned with the already indented braces.  
#                 This is because ACFS uses GNU indented style braces, not K&R indented style braces for control statements.
#             - K&R style for the parentheses is not as easy to read as the desired behavior .
#                 BUT IN THIS CASE, it is easier to read than the result of forcing the desired BreakBeforeParenthesis behavior.
#  >>>>>> - So it is best NOT to force non-indented Allman style.
#
#     - Multi-line function parameter/argument parentheses are formatted K&R style, not an indented Allman style.
#  >>>>>> - You can force an indented Allman style by placing an in-line comment after the function name.
#
#     - Multi-line assignments which place operators on their own line are not supported.
#  >>>>>> - You can force this behavior by placing an in-line comment at the end of the previous line.
#
#     - Multi-line assignments ending in ; on its own line is not supported (the ; is moved up to the end of the previous line).
#  >>>>>> - You can force this behavior by placing an in-line comment at the end of the previous line.
#
#     - Multi-line array initialization that requires special alignment is not formatted correctly.
#  >>>>>> - You should use format such multi-line array initialization manually and then protected
#             that formatting using "// clang-format off" before and "// clang-format on" after the array initialization,
#             as indicated in the Advisory Notes below.
#
#     - When nesting parentheses, it is not currently possible to separate consecutive parentheses with a space.
#         This means typing "int result = ( (a + b) * 3)", it will be formatted as "int result = ((a + b) * 3)"
#  >>>>>> - There is NO workaround.
#
#
# Advisory Notes:    <<<---IMPORTANT--->>>
#     - Use "// clang-format off" and "// clang-format on" to protect any manual formatting that you do not want clang-format to "fix".
#
#
# Useful Information:
#
#   To View/Edit this file, use Notepad++ (v6.2 or greater) with the User Defined Language (UDL v2.0 format) file "Notepad-pp_clang-format_UDL_este-este_vXX.xml".
#     - Turn on Word Wrap because there are some long lines in this file.
#     - Features of this UDL file:
#         - The "#" character in column 1 colorizes the line green.  Also begins an Inner Fold (see below).
#         - The "#" character in column 2 or higher colorizes the line black and allows recognition of UDL keywords that are colorized red.  
#           Also ends an Inner Fold (see below).
#             - A list of UDL keywords and their usage is at the end of this file.
#         - Nested folding
#             - Outer Fold:   FROM START line begins with "#`" TO END line begins with "#>>>>>"
#                 - Folds all lines FROM START TO END regardless of what is on the intervening lines.
#             - Inner Fold:   FROM START line begins with "#" TO END line DOES NOT begin with "#"
#                 - Folds only contiguous lines beginning with "#".
#                 - A line without "#" in column 1 will end the inner fold.  This includes a blank line.
#
#   Some command line options for the clang-format executable:
#
#     clang-format --help                         - Display available options (--help-hidden for more)
#     clang-format --help-list                    - Display list of available options (--help-list-hidden for more)
#     clang-format --version                      - Display the version of this program
#     clang-format --files=<filename>             - Specify the filename of a file containing a list of files to process, one per line.
#
#   Test command syntax:
#
#     clang-format --verbose --dry-run test.cpp     # Note:  you can use "-n" instead of "--dry-run"
#
#   Usage command syntax:
#
#     Format file test.cpp and output to test_formatted.cpp, using the .clang-format file in the same folder as test.cpp
#       clang-format test.cpp > test_formatted.cpp
#
#     Format file test.cpp in-place (output to itself), using the .clang-format file in the same folder as test.cpp
#       clang-format -i test.cpp                      # does an "in-place" format (original format is lost!)
#
#     Format file test.cpp and output to test_formatted.cpp, using the .clang-format file specified by the "--assume-filename=<filename>" option
#       clang-format --assume-filename=este_v1.02.clang-format test.cpp > test_formatted.cpp
#
#   Turn off clang-format in code:  // clang-format off
#   Turn on clang-format in code:   // clang-format on
#
#   Use a ".clang-format-ignore" file to make clang-format completely ignore certain files 
#   (See https://clang.llvm.org/docs/ClangFormat.html#:~:text=.-,clang%2Dformat%2Dignore,-%C2%B6)
#
#   Integration of the .clang-format file:
#     - Into Visual Studio, see https://learn.microsoft.com/en-us/visualstudio/ide/reference/options-text-editor-c-cpp-formatting?view=vs-2022 
#     - Into Arduinio IDE (v2.x), see https://docs.arduino.cc/software/ide-v2/tutorials/ide-v2-customize-auto-formatter/
#     - Into other tools, see https://clang.llvm.org/docs/ClangFormat.html 
#
#   Create a .clang-format file for a predefined style or particular options: 
#
#     LLCM style variants (a K&R brace indentation type)
#       clang-format -style=llvm -dump-config > llvm-1.clang-format
#       
#     Google style variants (a K&R brace indentation type)
#       clang-format -style=google -dump-config > google-1.clang-format
#
#     Microsoft style variants (an Allman brace indentation type)
#       clang-format -style=microsoft -dump-config > microsoft-1.clang-format
# 
#     GNU style variants (GNU brace indentation)
#       clang-format -style=gnu -dump-config > gnu-1.clang-format
#       clang-format -style="{BreakBeforeBraces : GNU}" -dump-config > gnu-2.clang-format
#
#     Allman style variants (Allman brace indentation)
#       clang-format -style="{BasedOnStyle : GNU, BreakBeforeBraces : Allman}" -dump-config > allman-1.clang-format
#       clang-format -style="{BreakBeforeBraces : Allman}" -dump-config > allman-2.clang-format
#
#   Clang-format options that I consider more important to know about:
#
#     BasedOnStyle:                    Use if one of the supported coding standards / style guides suits your needs.  Comment out to design your own code formatting style.  
#                                        When you specify one of the supported coding standards / style guides but also use a conflicting option value,
#                                        that conflicting option value will take precedence.
#                                        (If I had to pick from their list, my preference would be "GNU")
#     BreakBeforeBraces:               Pick one of the supported brace styles if it suits your needs.  Use value = Custom to design your own brace formatting style.
#                                        (If I had to pick from their list, my preference would be "Allman" or "GNU".)
#     BraceWrapping:                   If "BreakBeforeBraces: Custom", then you need to set your desired values for the BraceWrapping option.
#     AlignArrayOfStructures: None     Attempts to align fields into columns but it does not work well so avoid
#     DisableFormat:                   If set to true, disables the .clang-format file.
#     IndentPPDirectives:              Specifies preprocessor directive indenting style.
#     IndentWidth:                     Number of columns to use for indentation.
#     KeepEmptyLines:                  Determines which empty lines are kept.
#     Language:                        You can specify the language explicitly (though clang-format will otherwise uses the filename extension to figure this out).
#                                        However, it is not clear how clang-format uses that information.
#     SeparateDefinitionBlocks:        Specifies the use of empty lines to separate definition blocks, including classes, structs, enums, and functions.
#
#   Clang-format options that add new elements to achieve a code formatting style:
#
#     InsertBraces:       Adds wrapping braces to support a style that all control statements have a brace delimited code block (even if there is a single statement in code block).  
#
# Change Log:
#   - v1.03
#       - Initial release
#   - v1.04
#       - Changed AlignConsecutiveAssignments > AcrossComments = false
#           to better control how many lines the AlignConsecutiveAssignments option can affect.
#       - Changed AlignConsecutiveDeclarations > AcrossComments = false
#           to better control how many lines the AlignConsecutiveDeclarations option can affect.
#
# TODO:
#
#   - 
#          
# *******************************************************************************
# Inspired by the clang-format file of Ingmar Delsink (https://ingmar.dels.ink)
#   See http://clang.llvm.org/docs/ClangFormatStyleOptions.html
#>>>>>




# Common Options Section ------------------------------------------------------------------
#   Options set in this section are repeated in the Alphabetical Listing Section as commented out options since you cannot set the same option twice.
##########


#` BasedOnStyle (String) ¶    !!!!!***NOT USED***    <<<---IMPORTANT--->>>  Not using any of these built-in styles
# The style used for all options not specifically set in the configuration.
# 
# This option is supported only in the clang-format configuration (both within -style='{...}' and the .clang-format file).
# ---------------------------------------

# LLVM A style complying with the LLVM coding standards
# Google      A style complying with Google’s C++ style guide
# Chromium    A style complying with Chromium’s style guide
# Mozilla     A style complying with Mozilla’s style guide
# WebKit      A style complying with WebKit’s style guide
# Microsoft   A style complying with Microsoft’s style guide
# GNU         A style complying with the GNU coding standards
# 
# InheritParentConfig Not a real style, but allows to use the .clang-format file from the parent directory (or its parent if there is none). If there is no parent file found it falls back to the fallback style, and applies the changes to that.
# 
# With this option you can overwrite some parts of your main style for your subdirectories. This is also possible through the command line, e.g.: --style={BasedOnStyle: InheritParentConfig, ColumnLimit: 20}
# ---------------------------------------
#>>>>>
 # BasedOnStyle: 


#` TabWidth (Unsigned) clang-format 3.7 ¶
# The number of columns used for tab stops.
# ---------------------------------------
#>>>>>
TabWidth: 2


#` IndentWidth (Unsigned) clang-format 3.7 ¶
# The number of columns to use for indentation.
# ---------------------------------------

# Note:  other "...IndentWidth" options:
#   BracedInitializerIndentWidth, ConstructorInitializerIndentWidth, ContinuationIndentWidth, ObjCBlockIndentWidth, PPIndentWidth, 
# 
# IndentWidth: 3
# 
# void f() {
#    someFunction();
#    if (true, false) {
#       f();
#    }
# }
# ---------------------------------------
#>>>>>
IndentWidth: 2


#` UseTab (UseTabStyle) clang-format 3.7 ¶
# The way to use tab characters in the resulting file.
# ---------------------------------------

# UT_Never (in configuration: Never) Never use tab.
# UT_ForIndentation (in configuration: ForIndentation) Use tabs only for indentation.
# UT_ForContinuationAndIndentation (in configuration: ForContinuationAndIndentation) Fill all leading whitespace with tabs, and use spaces for alignment that appears within a line (e.g. consecutive assignments and declarations).
# UT_AlignWithSpaces (in configuration: AlignWithSpaces) Use tabs for line continuation and indentation, and spaces for alignment.
# UT_Always (in configuration: Always) Use tabs whenever we need to fill whitespace that spans at least from one tab stop to the next one.
# ---------------------------------------
#>>>>>
UseTab: Never


# C++ Sub-Section
#####


#` Language (LanguageKind) clang-format 3.5 ¶
# The language that this format style targets.
# 
# Note:
# You can also specify the language (Cpp or ObjC) for .h files by adding a // clang-format Language: line before the first non-comment (and non-empty) line, e.g. // clang-format Language: Cpp.
# ---------------------------------------

# LK_None (in configuration: None) Do not use.
# LK_Cpp (in configuration: Cpp) Should be used for C, C++.
# LK_CSharp (in configuration: CSharp) Should be used for C#.
# LK_Java (in configuration: Java) Should be used for Java.
# LK_JavaScript (in configuration: JavaScript) Should be used for JavaScript.
# LK_Json (in configuration: Json) Should be used for JSON.
# LK_ObjC (in configuration: ObjC) Should be used for Objective-C, Objective-C++.
# LK_Proto (in configuration: Proto) Should be used for Protocol Buffers (https://developers.google.com/protocol-buffers/).
# LK_TableGen (in configuration: TableGen) Should be used for TableGen code.
# LK_TextProto (in configuration: TextProto) Should be used for Protocol Buffer messages in text format (https://developers.google.com/protocol-buffers/).
# LK_Verilog (in configuration: Verilog) Should be used for Verilog and SystemVerilog. https://standards.ieee.org/ieee/1800/6700/ https://sci-hub.st/10.1109/IEEESTD.2018.8299595
# ---------------------------------------
#>>>>>
Language: Cpp


#` Standard (LanguageStandard) clang-format 3.7 ¶    !!!!!***NOT USED***  Not using any of these C++ standards
# Parse and format C++ constructs compatible with this standard.
# 
# c++03:                                 latest:
# vector<set<int> > x;           vs.     vector<set<int>> x;
# ---------------------------------------

# LS_Cpp03 (in configuration: c++03) Parse and format as C++03. Cpp03 is a deprecated alias for c++03
# LS_Cpp11 (in configuration: c++11) Parse and format as C++11.
# LS_Cpp14 (in configuration: c++14) Parse and format as C++14.
# LS_Cpp17 (in configuration: c++17) Parse and format as C++17.
# LS_Cpp20 (in configuration: c++20) Parse and format as C++20.
# LS_Latest (in configuration: Latest) Parse and format using the latest supported language version. Cpp11 is a deprecated alias for Latest
# LS_Auto (in configuration: Auto) Automatic detection based on the input.
# ---------------------------------------
#>>>>>
 # !_NOTE_! You might think that Standard: c++03 would format like this "Function(ReturnsInt1(a), ReturnsInt2(b) );" but you get this Function(ReturnsInt1(a), ReturnsInt2(b));"
 # Standard: c++11


#` PointerAlignment (PointerAlignmentStyle) clang-format 3.7 ¶
# Pointer and reference alignment style.
# ---------------------------------------
 
# PAS_Left (in configuration: Left) Align pointer to the left.
# 
# int* a;
# ---------------------------------------

# PAS_Right (in configuration: Right) Align pointer to the right.
# 
# int *a;
# ---------------------------------------

# PAS_Middle (in configuration: Middle) Align pointer in the middle.
# 
# int * a;
# ---------------------------------------
#>>>>>
PointerAlignment: Right




# Alphabetical Listing Section ------------------------------------------------------------------
#   This section is a complete listing of all clang-format options in the above stated current version for clang-format documentation.
#   As stated in the Common Options Section, options set above are commented out below since you cannot set the same option twice.
##########


# AccessModifierOffset (Integer)
# The extra indent or outdent of access modifiers, e.g. public:.
 # !_NOTE_! See IndentAccessModifiers for an explanation of how IndentAccessModifiers and AccessModifierOffset options interact.
AccessModifierOffset: 2


#` AlignAfterOpenBracket (BracketAlignmentStyle) clang-format 3.8 ¶
# If true, horizontally aligns arguments after an open bracket.
# 
# This applies to round brackets (parentheses), angle brackets and square brackets.
# ---------------------------------------

# BAS_Align (in configuration: Align) Align parameters on the open bracket, e.g.:
# 
# someLongFunction(argument1,
#                  argument2);
# ---------------------------------------

# BAS_DontAlign (in configuration: DontAlign) Don’t align, instead use ContinuationIndentWidth, e.g.:
# 
# someLongFunction(argument1,
#     argument2);
# ---------------------------------------

# BAS_AlwaysBreak (in configuration: AlwaysBreak) Always break after an open bracket, if the parameters don’t fit on a single line, e.g.:
# 
# someLongFunction(
#     argument1, argument2);
# ---------------------------------------

# BAS_BlockIndent (in configuration: BlockIndent) Always break after an open bracket, if the parameters don’t fit on a single line. Closing brackets will be placed on a new line. E.g.:
# 
# someLongFunction(
#     argument1, argument2
# )
# Note:
# This currently only applies to braced initializer lists (when Cpp11BracedListStyle is true) and parentheses.
# ---------------------------------------
#>>>>>
AlignAfterOpenBracket: BlockIndent


#` AlignArrayOfStructures (ArrayInitializerAlignmentStyle) clang-format 13 ¶
# When using initialization for an array of structs fields are aligned into columns.
# As of clang-format 15 this option only applied to arrays with equal number of columns per row.
# ---------------------------------------

# AIAS_Left (in configuration: Left) Align array column and left justify the columns e.g.:
# struct test demo[] =
# {
#    {56, 23,    "hello"},
#    {-1, 93463, "world"},
#    {7,  5,     "aa"   }
# };
# ---------------------------------------

# AIAS_Right (in configuration: Right) Align array column and right justify the columns e.g.:
# struct test demo[] =
# {
#     {56,    23, "hello"},
#     {-1, 93463, "world"},
#     { 7,     5,    "aa"}
# };
# ---------------------------------------

# AIAS_None (in configuration: None) Don’t align array initializer columns
# ---------------------------------------
#>>>>>
AlignArrayOfStructures: None


#` AlignConsecutiveAssignments (AlignConsecutiveStyle) clang-format 3.8 ¶
# Style of aligning consecutive assignments.
# ---------------------------------------

# bool Enabled Whether aligning is enabled.
# #define SHORT_NAME       42
# #define LONGER_NAME      0x007f
# #define EVEN_LONGER_NAME (2)
# #define foo(x)           (x * x)
# #define bar(y, z)        (y + z)
#
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
#
# int aaaa : 1;
# int b    : 12;
# int ccc  : 8;
#
# int         aaaa = 12;
# float       b = 23;
# std::string ccc;
# ---------------------------------------

# bool AcrossEmptyLines Whether to align across empty lines.
#
# true:
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
#
# int d            = 3;
#
# false:
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
#
# int d = 3;
# ---------------------------------------

# bool AcrossComments Whether to align across comments.
#
# true:
# int d    = 3;
# /* A comment. */
# double e = 4;
#
# false:
# int d = 3;
# /* A comment. */
# double e = 4;
# ---------------------------------------

# bool AlignCompound Only for AlignConsecutiveAssignments. Whether compound assignments like += are aligned along with =.
#
# true:
# a   &= 2;
# bbb  = 2;
#
# false:
# a &= 2;
# bbb = 2;
# ---------------------------------------

# bool AlignFunctionDeclarations Only for AlignConsecutiveDeclarations. Whether function declarations are aligned.
#
# true:
# unsigned int f1(void);
# void         f2(void);
# size_t       f3(void);
#
# false:
# unsigned int f1(void);
# void f2(void);
# size_t f3(void);
# ---------------------------------------

# bool AlignFunctionPointers Only for AlignConsecutiveDeclarations. Whether function pointers are aligned.
#
# true:
# unsigned i;
# int     &r;
# int     *p;
# int      (*f)();
#
# false:
# unsigned i;
# int     &r;
# int     *p;
# int (*f)();
# ---------------------------------------

# bool PadOperators Only for AlignConsecutiveAssignments. Whether short assignment operators are left-padded to the same length as long ones in order to put all assignment operators to the right of the left hand side.
#
# true:
# a   >>= 2;
# bbb   = 2;
#
# a     = 2;
# bbb >>= 2;
#
# false:
# a >>= 2;
# bbb = 2;
#
# a     = 2;
# bbb >>= 2;
# ---------------------------------------
#>>>>>
 # !_NOTE_! AlignConsecutiveAssignments: Enabled: true will align 
#             the variable name and the assignment operator by adding spaces before each such name and operator.
#           With AcrossEmptyLines: true and AcrossComments: true, this formatting can span many lines.
 # !!!!! !_NOTE_! AcrossComments: false is important to control the far reaching alignment that AcrossEmptyLines: true provides.
 #                Specifically, you can benefit from AcrossEmptyLines: true but stop the auto alignment by introducing an empty line comment.
AlignConsecutiveAssignments:
  Enabled: true
  AcrossEmptyLines: true
  AcrossComments: false
  
  AlignCompound: true
  PadOperators: true


#` AlignConsecutiveBitFields (AlignConsecutiveStyle) clang-format 11 ¶ 
# Style of aligning consecutive bit fields.
# 
# Consecutive will align the bitfield separators of consecutive lines. This will result in formattings like:
# 
# int aaaa : 1;
# int b    : 12;
# int ccc  : 8;
# ---------------------------------------

# Nested configuration flags:
# Alignment options.
# They can also be read as a whole for compatibility. The choices are:
# 
# None
# Consecutive
# AcrossEmptyLines
# AcrossComments
# AcrossEmptyLinesAndComments
# 
# For example, to align across empty lines and not across comments, either of these work.
# 
# AlignConsecutiveBitFields: AcrossEmptyLines
# 
# AlignConsecutiveBitFields:
#   Enabled: true
#   AcrossEmptyLines: true
#   AcrossComments: false
# ---------------------------------------

# bool Enabled Whether aligning is enabled.  <<<<< False is the default
# 
# #define SHORT_NAME       42
# #define LONGER_NAME      0x007f
# #define EVEN_LONGER_NAME (2)
# #define foo(x)           (x * x)
# #define bar(y, z)        (y + z)
# 
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
# 
# int aaaa : 1;
# int b    : 12;
# int ccc  : 8;
# 
# int         aaaa = 12;
# float       b = 23;
# std::string ccc;
# ---------------------------------------

# bool AcrossEmptyLines Whether to align across empty lines.
# 
# true:
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
# 
# int d            = 3;
# 
# false:
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
# 
# int d = 3;
# ---------------------------------------

# bool AcrossComments Whether to align across comments.
# 
# true:
# int d    = 3;
# /* A comment. */
# double e = 4;
# 
# false:
# int d = 3;
# /* A comment. */
# double e = 4;
# ---------------------------------------

# bool AlignCompound Only for AlignConsecutiveAssignments. Whether compound assignments like += are aligned along with =.
# 
# true:
# a   &= 2;
# bbb  = 2;
# 
# false:
# a &= 2;
# bbb = 2;
# ---------------------------------------

# bool AlignFunctionDeclarations Only for AlignConsecutiveDeclarations. Whether function declarations are aligned.
# 
# true:
# unsigned int f1(void);
# void         f2(void);
# size_t       f3(void);
# 
# false:
# unsigned int f1(void);
# void f2(void);
# size_t f3(void);
# ---------------------------------------

# bool AlignFunctionPointers Only for AlignConsecutiveDeclarations. Whether function pointers are aligned.
# 
# true:
# unsigned i;
# int     &r;
# int     *p;
# int      (*f)();
# 
# false:
# unsigned i;
# int     &r;
# int     *p;
# int (*f)();
# ---------------------------------------

# bool PadOperators Only for AlignConsecutiveAssignments. Whether short assignment operators are left-padded to the same length as long ones in order to put all assignment operators to the right of the left hand side.
# 
# true:
# a   >>= 2;
# bbb   = 2;
# 
# a     = 2;
# bbb >>= 2;
# 
# false:
# a >>= 2;
# bbb = 2;
# 
# a     = 2;
# bbb >>= 2;
# ---------------------------------------
#>>>>>
AlignConsecutiveBitFields: false


#` AlignConsecutiveDeclarations (AlignConsecutiveStyle) clang-format 3.8 ¶        This is actually partly incorrect.
# Style of aligning consecutive declarations.
# ---------------------------------------

# bool Enabled Whether aligning is enabled.
#
# #define SHORT_NAME       42
# #define LONGER_NAME      0x007f
# #define EVEN_LONGER_NAME (2)
# #define foo(x)           (x * x)
# #define bar(y, z)        (y + z)
#
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
#
# int aaaa : 1;
# int b    : 12;
# int ccc  : 8;
#
# int         aaaa = 12;
# float       b = 23;
# std::string ccc;
# ---------------------------------------

# bool AcrossEmptyLines Whether to align across empty lines.
#
# true:
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
#
# int d            = 3;
#
# false:
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
#
# int d = 3;
# ---------------------------------------

# bool AcrossComments Whether to align across comments.
#
# true:
# int d    = 3;
# /* A comment. */
# double e = 4;
#
# false:
# int d = 3;
# /* A comment. */
# double e = 4;
# ---------------------------------------

# bool AlignCompound Only for AlignConsecutiveAssignments. Whether compound assignments like += are aligned along with =.
#
# true:
# a   &= 2;
# bbb  = 2;
#
# false:
# a &= 2;
# bbb = 2;
# ---------------------------------------

# bool AlignFunctionDeclarations Only for AlignConsecutiveDeclarations. Whether function declarations are aligned.      This is incorrect and does not actually exist!
#
# true:
# unsigned int f1(void);
# void         f2(void);
# size_t       f3(void);
#
# false:
# unsigned int f1(void);
# void f2(void);
# size_t f3(void);
# ---------------------------------------

# bool AlignFunctionPointers Only for AlignConsecutiveDeclarations. Whether function pointers are aligned.
#
# true:
# unsigned i;
# int     &r;
# int     *p;
# int      (*f)();
#
# false:
# unsigned i;
# int     &r;
# int     *p;
# int (*f)();
# ---------------------------------------

# bool PadOperators Only for AlignConsecutiveAssignments. Whether short assignment operators are left-padded to the same length as long ones in order to put all assignment operators to the right of the left hand side.
#
# true:
# a   >>= 2;
# bbb   = 2;
#
# a     = 2;
# bbb >>= 2;
#
# false:
# a >>= 2;
# bbb = 2;
#
# a     = 2;
# bbb >>= 2;
# ---------------------------------------
#>>>>>
 # !!!!! !_NOTE_! AcrossComments: false is important to control the far reaching alignment that AcrossEmptyLines: true provides.
 #                Specifically, you can benefit from AcrossEmptyLines: true but stop the auto alignment by introducing an empty line comment.
AlignConsecutiveDeclarations:
  Enabled: true
  AcrossEmptyLines: true
  AcrossComments: false
  
 # AlignFunctionDeclarations: true
  AlignFunctionPointers: true
  
   
#` AlignConsecutiveMacros (AlignConsecutiveStyle) clang-format 9 ¶
# Style of aligning consecutive macro definitions.
# ---------------------------------------

# bool Enabled Whether aligning is enabled.
#
# #define SHORT_NAME       42
# #define LONGER_NAME      0x007f
# #define EVEN_LONGER_NAME (2)
# #define foo(x)           (x * x)
# #define bar(y, z)        (y + z)
#
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
#
# int aaaa : 1;
# int b    : 12;
# int ccc  : 8;
#
# int         aaaa = 12;
# float       b = 23;
# std::string ccc;
# ---------------------------------------

# bool AcrossEmptyLines Whether to align across empty lines.
#
# true:
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
#
# int d            = 3;
#
# false:
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
#
# int d = 3;
# ---------------------------------------

# bool AcrossComments Whether to align across comments.
#
# true:
# int d    = 3;
# /* A comment. */
# double e = 4;
#
# false:
# int d = 3;
# /* A comment. */
# double e = 4;
# ---------------------------------------

# bool AlignCompound Only for AlignConsecutiveAssignments. Whether compound assignments like += are aligned along with =.
#
# true:
# a   &= 2;
# bbb  = 2;
#
# false:
# a &= 2;
# bbb = 2;
# ---------------------------------------

# bool AlignFunctionDeclarations Only for AlignConsecutiveDeclarations. Whether function declarations are aligned.
#
# true:
# unsigned int f1(void);
# void         f2(void);
# size_t       f3(void);
#
# false:
# unsigned int f1(void);
# void f2(void);
# size_t f3(void);
# ---------------------------------------

# bool AlignFunctionPointers Only for AlignConsecutiveDeclarations. Whether function pointers are aligned.
#
# true:
# unsigned i;
# int     &r;
# int     *p;
# int      (*f)();
#
# false:
# unsigned i;
# int     &r;
# int     *p;
# int (*f)();
# ---------------------------------------

# bool PadOperators Only for AlignConsecutiveAssignments. Whether short assignment operators are left-padded to the same length as long ones in order to put all assignment operators to the right of the left hand side.
#
# true:
# a   >>= 2;
# bbb   = 2;
#
# a     = 2;
# bbb >>= 2;
#
# false:
# a >>= 2;
# bbb = 2;
#
# a     = 2;
# bbb >>= 2;  
# ---------------------------------------
#>>>>>
AlignConsecutiveMacros:  
  Enabled: true
  AcrossEmptyLines: true
  AcrossComments: false
  # AlignCompound:
  # AlignFunctionDeclarations:
  # AlignFunctionPointers:
  # PadOperators:


#` AlignConsecutiveShortCaseStatements (ShortCaseStatementsAlignmentStyle) clang-format 17 ¶
# Style of aligning consecutive short case labels. Only applies if AllowShortCaseExpressionOnASingleLine or AllowShortCaseLabelsOnASingleLine is true.
# ---------------------------------------

# bool Enabled Whether aligning is enabled.
#
# true:
# switch (level) {
# case log::info:    return "info:";
# case log::warning: return "warning:";
# default:           return "";
# }
#
# false:
# switch (level) {
# case log::info: return "info:";
# case log::warning: return "warning:";
# default: return "";
# }
# ---------------------------------------

# bool AcrossEmptyLines Whether to align across empty lines.
#
# true:
# switch (level) {
# case log::info:    return "info:";
# case log::warning: return "warning:";
#
# default:           return "";
# }
#
# false:
# switch (level) {
# case log::info:    return "info:";
# case log::warning: return "warning:";
#
# default: return "";
# }
# ---------------------------------------

# bool AcrossComments Whether to align across comments.
#
# true:
# switch (level) {
# case log::info:    return "info:";
# case log::warning: return "warning:";
# /* A comment. */
# default:           return "";
# }
#
# false:
# switch (level) {
# case log::info:    return "info:";
# case log::warning: return "warning:";
# /* A comment. */
# default: return "";
# }
# ---------------------------------------

# bool AlignCaseArrows Whether to align the case arrows when aligning short case expressions.         TODO need to fix the "#" here
#
# true:
# i = switch (day) {
  # case THURSDAY, SATURDAY -> 8;
  # case WEDNESDAY          -> 9;
  # default                 -> 0;
# };
#
# false:
# i = switch (day) {
  # case THURSDAY, SATURDAY -> 8;
  # case WEDNESDAY ->          9;
  # default ->                 0;
# };
# ---------------------------------------

# bool AlignCaseColons Whether aligned case labels are aligned on the colon, or on the tokens after the colon.
#
# true:
# switch (level) {
# case log::info   : return "info:";
# case log::warning: return "warning:";
# default          : return "";
# }
#
# false:
# switch (level) {
# case log::info:    return "info:";
# case log::warning: return "warning:";
# default:           return "";
# }
# ---------------------------------------
#>>>>>
AlignConsecutiveShortCaseStatements: 
  Enabled: false


#` AlignConsecutiveTableGenBreakingDAGArgColons (AlignConsecutiveStyle) clang-format 19 ¶
# Style of aligning consecutive TableGen DAGArg operator colons. If enabled, align the colon inside DAGArg which have line break inside. This works only when TableGenBreakInsideDAGArg is BreakElements or BreakAll and the DAGArg is not excepted by TableGenBreakingDAGArgOperators’s effect.
# 
# let dagarg = (ins
#     a  :$src1,
#     aa :$src2,
#     aaa:$src3
# )
# ---------------------------------------

# Nested configuration flags:
# Alignment options.
# 
# They can also be read as a whole for compatibility. The choices are:
# 
# None
# Consecutive
# AcrossEmptyLines
# AcrossComments
# AcrossEmptyLinesAndComments
# 
# For example, to align across empty lines and not across comments, either of these work.
# 
# AlignConsecutiveTableGenBreakingDAGArgColons: AcrossEmptyLines
# 
# AlignConsecutiveTableGenBreakingDAGArgColons:
#   Enabled: true
#   AcrossEmptyLines: true
#   AcrossComments: false
# ---------------------------------------

# bool Enabled Whether aligning is enabled.  <<<<< False is the default
# 
# #define SHORT_NAME       42
# #define LONGER_NAME      0x007f
# #define EVEN_LONGER_NAME (2)
# #define foo(x)           (x * x)
# #define bar(y, z)        (y + z)
# 
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
# 
# int aaaa : 1;
# int b    : 12;
# int ccc  : 8;
# 
# int         aaaa = 12;
# float       b = 23;
# std::string ccc;
# ---------------------------------------

# bool AcrossEmptyLines Whether to align across empty lines.
# 
# true:
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
# 
# int d            = 3;
# 
# false:
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
# 
# int d = 3;
# ---------------------------------------

# bool AcrossComments Whether to align across comments.
# 
# true:
# int d    = 3;
# /* A comment. */
# double e = 4;
# 
# false:
# int d = 3;
# /* A comment. */
# double e = 4;
# ---------------------------------------

# bool AlignCompound Only for AlignConsecutiveAssignments. Whether compound assignments like += are aligned along with =.
# 
# true:
# a   &= 2;
# bbb  = 2;
# 
# false:
# a &= 2;
# bbb = 2;
# ---------------------------------------

# bool AlignFunctionDeclarations Only for AlignConsecutiveDeclarations. Whether function declarations are aligned.
# 
# true:
# unsigned int f1(void);
# void         f2(void);
# size_t       f3(void);
# 
# false:
# unsigned int f1(void);
# void f2(void);
# size_t f3(void);
# ---------------------------------------

# bool AlignFunctionPointers Only for AlignConsecutiveDeclarations. Whether function pointers are aligned.
# 
# true:
# unsigned i;
# int     &r;
# int     *p;
# int      (*f)();
# 
# false:
# unsigned i;
# int     &r;
# int     *p;
# int (*f)();
# ---------------------------------------

# bool PadOperators Only for AlignConsecutiveAssignments. Whether short assignment operators are left-padded to the same length as long ones in order to put all assignment operators to the right of the left hand side.
# 
# true:
# a   >>= 2;
# bbb   = 2;
# 
# a     = 2;
# bbb >>= 2;
# 
# false:
# a >>= 2;
# bbb = 2;
# 
# a     = 2;
# bbb >>= 2;
# ---------------------------------------
#>>>>>
AlignConsecutiveTableGenBreakingDAGArgColons:
  Enabled: false
 
 
#` AlignConsecutiveTableGenCondOperatorColons (AlignConsecutiveStyle) clang-format 19 ¶
# Style of aligning consecutive TableGen cond operator colons. Align the colons of cases inside !cond operators. 
# 
# !cond(!eq(size, 1) : 1,
#       !eq(size, 16): 1,
#       true         : 0)
# ---------------------------------------

# Nested configuration flags:
# Alignment options.
# 
# They can also be read as a whole for compatibility. The choices are:
# 
# None
# Consecutive
# AcrossEmptyLines
# AcrossComments
# AcrossEmptyLinesAndComments
# 
# For example, to align across empty lines and not across comments, either of these work.
# 
# AlignConsecutiveTableGenCondOperatorColons: AcrossEmptyLines
# 
# AlignConsecutiveTableGenCondOperatorColons:
#   Enabled: true
#   AcrossEmptyLines: true
#   AcrossComments: false
# ---------------------------------------

# bool Enabled Whether aligning is enabled.  <<<<< False is the default
# 
# #define SHORT_NAME       42
# #define LONGER_NAME      0x007f
# #define EVEN_LONGER_NAME (2)
# #define foo(x)           (x * x)
# #define bar(y, z)        (y + z)
# 
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
# 
# int aaaa : 1;
# int b    : 12;
# int ccc  : 8;
# 
# int         aaaa = 12;
# float       b = 23;
# std::string ccc;
# ---------------------------------------

# bool AcrossEmptyLines Whether to align across empty lines.
# 
# true:
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
# 
# int d            = 3;
# 
# false:
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
# 
# int d = 3;
# ---------------------------------------

# bool AcrossComments Whether to align across comments.
# 
# true:
# int d    = 3;
# /* A comment. */
# double e = 4;
# 
# false:
# int d = 3;
# /* A comment. */
# double e = 4;
# ---------------------------------------

# bool AlignCompound Only for AlignConsecutiveAssignments. Whether compound assignments like += are aligned along with =.
# 
# true:
# a   &= 2;
# bbb  = 2;
# 
# false:
# a &= 2;
# bbb = 2;
# ---------------------------------------

# bool AlignFunctionDeclarations Only for AlignConsecutiveDeclarations. Whether function declarations are aligned.
# 
# true:
# unsigned int f1(void);
# void         f2(void);
# size_t       f3(void);
# 
# false:
# unsigned int f1(void);
# void f2(void);
# size_t f3(void);
# ---------------------------------------

# bool AlignFunctionPointers Only for AlignConsecutiveDeclarations. Whether function pointers are aligned.
# 
# true:
# unsigned i;
# int     &r;
# int     *p;
# int      (*f)();
# 
# false:
# unsigned i;
# int     &r;
# int     *p;
# int (*f)();
# ---------------------------------------

# bool PadOperators Only for AlignConsecutiveAssignments. Whether short assignment operators are left-padded to the same length as long ones in order to put all assignment operators to the right of the left hand side.
# 
# true:
# a   >>= 2;
# bbb   = 2;
# 
# a     = 2;
# bbb >>= 2;
# 
# false:
# a >>= 2;
# bbb = 2;
# 
# a     = 2;
# bbb >>= 2;
# ---------------------------------------
#>>>>>
AlignConsecutiveTableGenCondOperatorColons:
  Enabled: false


#` AlignConsecutiveTableGenDefinitionColons (AlignConsecutiveStyle) clang-format 19 ¶
# Style of aligning consecutive TableGen definition colons. This aligns the inheritance colons of consecutive definitions.  
# 
# def Def       : Parent {}
# def DefDef    : Parent {}
# def DefDefDef : Parent {}
# ---------------------------------------

# Nested configuration flags:
# Alignment options.
# 
# They can also be read as a whole for compatibility. The choices are:
# 
# None
# Consecutive
# AcrossEmptyLines
# AcrossComments
# AcrossEmptyLinesAndComments

# For example, to align across empty lines and not across comments, either of these work.
# 
# AlignConsecutiveTableGenDefinitionColons: AcrossEmptyLines
# 
# AlignConsecutiveTableGenDefinitionColons:
#   Enabled: true
#   AcrossEmptyLines: true
#   AcrossComments: false
# ---------------------------------------

# bool Enabled Whether aligning is enabled.  <<<<< False is the default
# 
# #define SHORT_NAME       42
# #define LONGER_NAME      0x007f
# #define EVEN_LONGER_NAME (2)
# #define foo(x)           (x * x)
# #define bar(y, z)        (y + z)
# 
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
# 
# int aaaa : 1;
# int b    : 12;
# int ccc  : 8;
# 
# int         aaaa = 12;
# float       b = 23;
# std::string ccc;
# ---------------------------------------

# bool AcrossEmptyLines Whether to align across empty lines.
# 
# true:
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
# 
# int d            = 3;
# 
# false:
# int a            = 1;
# int somelongname = 2;
# double c         = 3;
# 
# int d = 3;
# ---------------------------------------

# bool AcrossComments Whether to align across comments.
# 
# true:
# int d    = 3;
# /* A comment. */
# double e = 4;
# 
# false:
# int d = 3;
# /* A comment. */
# double e = 4;
# ---------------------------------------

# bool AlignCompound Only for AlignConsecutiveAssignments. Whether compound assignments like += are aligned along with =.
# 
# true:
# a   &= 2;
# bbb  = 2;
# 
# false:
# a &= 2;
# bbb = 2;
# ---------------------------------------

# bool AlignFunctionDeclarations Only for AlignConsecutiveDeclarations. Whether function declarations are aligned.
# 
# true:
# unsigned int f1(void);
# void         f2(void);
# size_t       f3(void);
# 
# false:
# unsigned int f1(void);
# void f2(void);
# size_t f3(void);
# ---------------------------------------

# bool AlignFunctionPointers Only for AlignConsecutiveDeclarations. Whether function pointers are aligned.
# 
# true:
# unsigned i;
# int     &r;
# int     *p;
# int      (*f)();
# 
# false:
# unsigned i;
# int     &r;
# int     *p;
# int (*f)();
# ---------------------------------------

# bool PadOperators Only for AlignConsecutiveAssignments. Whether short assignment operators are left-padded to the same length as long ones in order to put all assignment operators to the right of the left hand side.
# 
# true:
# a   >>= 2;
# bbb   = 2;
# 
# a     = 2;
# bbb >>= 2;
# 
# false:
# a >>= 2;
# bbb = 2;
# 
# a     = 2;
# bbb >>= 2;
# ---------------------------------------
#>>>>>
AlignConsecutiveTableGenDefinitionColons:
  Enabled: false


#` AlignEscapedNewlines (EscapedNewlineAlignmentStyle) clang-format 5 ¶
# Options for aligning backslashes in escaped newlines.
# ---------------------------------------

# ENAS_DontAlign (in configuration: DontAlign) Don’t align escaped newlines.
# #define A \
#   int aaaa; \
#   int b; \
#   int dddddddddd;
# ---------------------------------------

# ENAS_Left (in configuration: Left) Align escaped newlines as far left as possible.
# #define A   \
#   int aaaa; \
#   int b;    \
#   int dddddddddd;
# ---------------------------------------

# ENAS_LeftWithLastLine (in configuration: LeftWithLastLine) Align escaped newlines as far left as possible, using the last line of the preprocessor directive as the reference if it’s the longest.
# #define A         \
#   int aaaa;       \
#   int b;          \
#   int dddddddddd;
# ---------------------------------------

# ENAS_Right (in configuration: Right) Align escaped newlines in the right-most column.
# #define A                                                                      \
#   int aaaa;                                                                    \
#   int b;                                                                       \
#   int dddddddddd;  
# ---------------------------------------
#>>>>>
AlignEscapedNewlines:  LeftWithLastLine
  

#` AlignOperands (OperandAlignmentStyle) clang-format 3.5 ¶
# If true, horizontally align operands of binary and ternary expressions.
# ---------------------------------------

# OAS_DontAlign (in configuration: DontAlign) Do not align operands of binary and ternary expressions. The wrapped lines are indented ContinuationIndentWidth spaces from the start of the line.
# ---------------------------------------

# OAS_Align (in configuration: Align) Horizontally align operands of binary and ternary expressions.
# Specifically, this aligns operands of a single expression that needs to be split over multiple lines, e.g.:
# 
# int aaa = bbbbbbbbbbbbbbb +
#           ccccccccccccccc;
# When BreakBeforeBinaryOperators is set, the wrapped operator is aligned with the operand on the first line.
# 
# int aaa = bbbbbbbbbbbbbbb
#           + ccccccccccccccc;
# ---------------------------------------

# OAS_AlignAfterOperator (in configuration: AlignAfterOperator) Horizontally align operands of binary and ternary expressions.
# 
# This is similar to OAS_Align, except when BreakBeforeBinaryOperators is set, the operator is un-indented so that the wrapped operand is aligned with the operand on the first line.
# 
# int aaa = bbbbbbbbbbbbbbb
#         + ccccccccccccccc;
# ---------------------------------------
#>>>>>
AlignOperands: Align


#` AlignTrailingComments (TrailingCommentsAlignmentStyle) clang-format 3.7 ¶
# Control of trailing comments.
# The alignment stops at closing braces after a line break, and only followed by other closing braces, a (do-) while, a lambda call, or a semicolon.
#
# As of clang-format 16 this option is not a bool but can be set to the options. Conventional bool options still can be parsed as before.
# 
# Example of usage:
# AlignTrailingComments:
#   Kind: Always
#   OverEmptyLines: 2
# Nested configuration flags:
# 
# Alignment options
# 
# TrailingCommentsAlignmentKinds Kind Specifies the way to align trailing comments.
# 
# Possible values:
# ---------------------------------------

# TCAS_Leave (in configuration: Leave) Leave trailing comments as they are.
# 
# int a;    // comment
# int ab;       // comment
# 
# int abc;  // comment
# int abcd;     // comment
# ---------------------------------------

# TCAS_Always (in configuration: Always) Align trailing comments.
# 
# int a;  // comment
# int ab; // comment
# 
# int abc;  // comment
# int abcd; // comment
# ---------------------------------------

# TCAS_Never (in configuration: Never) Don’t align trailing comments but other formatter applies.
# 
# int a; // comment
# int ab; // comment
# 
# int abc; // comment
# int abcd; // comment
# ---------------------------------------

# unsigned OverEmptyLines How many empty lines to apply alignment. When both MaxEmptyLinesToKeep and OverEmptyLines are set to 2, it formats like below.
# 
# int a;      // all these
# 
# int ab;     // comments are
# 
# 
# int abcdef; // aligned
#
# When MaxEmptyLinesToKeep is set to 2 and OverEmptyLines is set to 1, it formats like below.
# 
# int a;  // these are
# 
# int ab; // aligned
# 
# 
# int abcdef; // but this isn't
# ---------------------------------------
#>>>>>
AlignTrailingComments: 
  Kind: Always  
  OverEmptyLines: 0


#` AllowAllArgumentsOnNextLine (Boolean) clang-format 9 ¶
# If a function call or braced initializer list doesn’t fit on a line, allow putting all arguments onto the next line, even if BinPackArguments is false.
# 
# true:
# callFunction(
#     a, b, c, d);
# 
# false:
# callFunction(a,
#              b,
#              c,
#              d); 
# --------------------------------------- 
#>>>>>
AllowAllArgumentsOnNextLine: false  


#` AllowAllParametersOfDeclarationOnNextLine (Boolean) clang-format 3.3 ¶
# If the function declaration doesn’t fit on a line, allow putting all parameters of a function declaration onto the next line even if BinPackParameters is OnePerLine.
# 
# true:
# void myFunction(
#     int a, int b, int c, int d, int e);
# 
# false:
# void myFunction(int a,
#                 int b,
#                 int c,
#                 int d,
#                 int e);  
# ---------------------------------------
#>>>>>
AllowAllParametersOfDeclarationOnNextLine: false  


#` AllowBreakBeforeNoexceptSpecifier (BreakBeforeNoexceptSpecifierStyle) clang-format 18 ¶
# Controls if there could be a line break before a noexcept specifier.
# ---------------------------------------

# BBNSS_Never (in configuration: Never) No line break allowed.  <<<<< Never is the default
# 
# void foo(int arg1,
#          double arg2) noexcept;
# 
# void bar(int arg1, double arg2) noexcept(
#     noexcept(baz(arg1)) &&
#     noexcept(baz(arg2)));
# ---------------------------------------

# BBNSS_OnlyWithParen (in configuration: OnlyWithParen) For a simple noexcept there is no line break allowed, but when we have a condition it is.
# 
# void foo(int arg1,
#          double arg2) noexcept;
# 
# void bar(int arg1, double arg2)
#     noexcept(noexcept(baz(arg1)) &&
#              noexcept(baz(arg2)));
# ---------------------------------------

# BBNSS_Always (in configuration: Always) Line breaks are allowed. But note that because of the associated penalties clang-format often prefers not to break before the noexcept.
# 
# void foo(int arg1,
#          double arg2) noexcept;
# 
# void bar(int arg1, double arg2)
#     noexcept(noexcept(baz(arg1)) &&
#              noexcept(baz(arg2)));  
# ---------------------------------------
#>>>>>
AllowBreakBeforeNoexceptSpecifier: Never


#` AllowShortBlocksOnASingleLine (ShortBlockStyle) clang-format 3.5 ¶
# Dependent on the value, while (true) { continue; } can be put on a single line.
# ---------------------------------------
 
# SBS_Never (in configuration: Never) Never merge blocks into a single line.
# 
# while (true) {
# }
# while (true) {
#   continue;
# }
# ---------------------------------------

# SBS_Empty (in configuration: Empty) Only merge empty blocks.
# 
# while (true) {}
# while (true) {
#   continue;
# }
# ---------------------------------------

# SBS_Always (in configuration: Always) Always merge short blocks into a single line.
# 
# while (true) {}
# while (true) { continue; }        
# ---------------------------------------
#>>>>>     
AllowShortBlocksOnASingleLine: Never  


#` AllowShortCaseExpressionOnASingleLine (Boolean) clang-format 19 ¶
# Whether to merge a short switch labeled rule into a single line.
# 
# true:                               false:
# switch (a) {           vs.          switch (a) {
# case 1 -> 1;                        case 1 ->
# default -> 0;                         1;
# };                                  default ->
#                                       0;
#                                     };  
# ---------------------------------------
#>>>>>
AllowShortCaseExpressionOnASingleLine: false
 

#` AllowShortCaseLabelsOnASingleLine (Boolean) clang-format 3.6 ¶
# If true, short case labels will be contracted to a single line.
# 
# true:                                   false:
# switch (a) {                    vs.     switch (a) {
# case 1: x = 1; break;                   case 1:
# case 2: return;                           x = 1;
# }                                         break;
#                                         case 2:
#                                           return;
#                                         }
# ---------------------------------------
#>>>>>
AllowShortCaseLabelsOnASingleLine:  false


#` AllowShortCompoundRequirementOnASingleLine (Boolean) clang-format 18 ¶
# Allow short compound requirement on a single line.
# 
# true:
# template <typename T>
# concept c = requires(T x) {
#   { x + 1 } -> std::same_as<int>;
# };
# 
# false:
# template <typename T>
# concept c = requires(T x) {
#   {
#     x + 1
#   } -> std::same_as<int>;
# };
# ---------------------------------------
#>>>>>
AllowShortCompoundRequirementOnASingleLine: false


#` AllowShortEnumsOnASingleLine (Boolean) clang-format 11 ¶
# Allow short enums on a single line.
# 
# true:
# enum { A, B } myEnum;
# 
# false:
# enum {
#   A,
#   B
# } myEnum;
# ---------------------------------------
#>>>>>
AllowShortEnumsOnASingleLine: false


#` AllowShortFunctionsOnASingleLine (ShortFunctionStyle) clang-format 3.5 ¶
# Dependent on the value, int f() { return 0; } can be put on a single line.
# ---------------------------------------

# SFS_None (in configuration: None) Never merge functions into a single line.
# ---------------------------------------

# SFS_InlineOnly (in configuration: InlineOnly) Only merge functions defined inside a class. Same as inline, except it does not implies empty: i.e. top level empty functions are not merged either.
# 
# class Foo {
#   void f() { foo(); }
# };
# void f() {
#   foo();
# }
# void f() {
# }
# ---------------------------------------

# SFS_Empty (in configuration: Empty) Only merge empty functions.
# 
# void f() {}
# void f2() {
#   bar2();
# }
# ---------------------------------------

# SFS_Inline (in configuration: Inline) Only merge functions defined inside a class. Implies empty.
# 
# class Foo {
#   void f() { foo(); }
# };
# void f() {
#   foo();
# }
# void f() {}
# ---------------------------------------

# SFS_All (in configuration: All) Merge all functions fitting on a single line.
# 
# class Foo {
#   void f() { foo(); }
# };
# void f() { bar(); }
# ---------------------------------------
#>>>>>
AllowShortFunctionsOnASingleLine: None


#` AllowShortIfStatementsOnASingleLine (ShortIfStyle) clang-format 3.3 ¶
# Dependent on the value, if (a) return; can be put on a single line.
# ---------------------------------------

# SIS_Never (in configuration: Never) Never put short ifs on the same line.
# 
# if (a)
#   return;
# 
# if (b)
#   return;
# else
#   return;
# 
# if (c)
#   return;
# else {
#   return;
# }
# ---------------------------------------

# SIS_WithoutElse (in configuration: WithoutElse) Put short ifs on the same line only if there is no else statement.
# 
# if (a) return;
# 
# if (b)
#   return;
# else
#   return;
# 
# if (c)
#   return;
# else {
#   return;
# }
# ---------------------------------------

# SIS_OnlyFirstIf (in configuration: OnlyFirstIf) Put short ifs, but not else ifs nor else statements, on the same line.
# 
# if (a) return;
# 
# if (b) return;
# else if (b)
#   return;
# else
#   return;
# 
# if (c) return;
# else {
#   return;
# }
# ---------------------------------------

# SIS_AllIfsAndElse (in configuration: AllIfsAndElse) Always put short ifs, else ifs and else statements on the same line.
# 
# if (a) return;
# 
# if (b) return;
# else return;
# 
# if (c) return;
# else {
#   return;
# }
# ---------------------------------------
#>>>>>
AllowShortIfStatementsOnASingleLine: Never


#` AllowShortLambdasOnASingleLine (ShortLambdaStyle) clang-format 9 ¶
# Dependent on the value, auto lambda []() { return 0; } can be put on a single line.
# ---------------------------------------

# SLS_None (in configuration: None) Never merge lambdas into a single line.
# ---------------------------------------

# SLS_Empty (in configuration: Empty) Only merge empty lambdas.
# 
# auto lambda = [](int a) {};
# auto lambda2 = [](int a) {
#     return a;
# };
# ---------------------------------------

# SLS_Inline (in configuration: Inline) Merge lambda into a single line if the lambda is argument of a function.
# 
# auto lambda = [](int x, int y) {
#     return x < y;
# };
# sort(a.begin(), a.end(), [](int x, int y) { return x < y; });
# ---------------------------------------

# SLS_All (in configuration: All) Merge all lambdas fitting on a single line.
# 
# auto lambda = [](int a) {};
# auto lambda2 = [](int a) { return a; };
# ---------------------------------------
#>>>>>
AllowShortLambdasOnASingleLine: None


#` AllowShortLoopsOnASingleLine (Boolean) clang-format 3.7 ¶
# If true, while (true) continue; can be put on a single line.
# ---------------------------------------
#>>>>>
AllowShortLoopsOnASingleLine: false


#` AllowShortNamespacesOnASingleLine (Boolean) clang-format 20 ¶    !!!!!***NOT USED***  beyond clang-format 19
# If true, namespace a { class b; } can be put on a single line.
# ---------------------------------------
#>>>>>
 # AllowShortLoopsOnASingleLine: 


#` AlwaysBreakAfterDefinitionReturnType (DefinitionReturnTypeBreakingStyle) clang-format 3.7 ¶    !!!!!***NOT USED***  deprecated
# The function definition return type breaking style to use. This option is deprecated and is retained for backwards compatibility.
# ---------------------------------------

# DRTBS_None (in configuration: None) Break after return type automatically. PenaltyReturnTypeOnItsOwnLine is taken into account.
# DRTBS_All (in configuration: All) Always break after the return type.
# DRTBS_TopLevel (in configuration: TopLevel) Always break after the return types of top-level functions.
# ---------------------------------------
#>>>>>
 # AlwaysBreakAfterDefinitionReturnType:

#` AlwaysBreakAfterReturnType (deprecated) clang-format 3.8 ¶    !!!!!***NOT USED***  deprecated - Renamed to BreakAfterReturnType.
# This option is renamed to BreakAfterReturnType.
# ---------------------------------------
#>>>>>
 # AlwaysBreakAfterReturnType:

#` AlwaysBreakBeforeMultilineStrings (Boolean) clang-format 3.4 ¶
# If true, always break before multiline string literals.
# 
# This flag is mean to make cases where there are multiple multiline strings in a file look more consistent. Thus, it will only take effect if wrapping the string at that point leads to it being indented ContinuationIndentWidth spaces from the start of the line.
# 
# true:                                  false:
# aaaa =                         vs.     aaaa = "bbbb"
#     "bbbb"                                    "cccc";
#     "cccc";
# ---------------------------------------
#>>>>>
AlwaysBreakBeforeMultilineStrings: true


#` AlwaysBreakTemplateDeclarations (deprecated) clang-format 3.4 ¶    !!!!!***NOT USED***  deprecated - Renamed to BreakTemplateDeclarations.
# This option is renamed to BreakTemplateDeclarations.
# ---------------------------------------
#>>>>>
 # AlwaysBreakTemplateDeclarations: 


#` AttributeMacros (List of Strings) clang-format 12 ¶   !!!!!***NOT USED***  (List of Strings)
# A vector of strings that should be interpreted as attributes/qualifiers instead of identifiers. This can be useful for language extensions or static analyzer annotations.
# 
# For example:
# 
# x = (char *__capability)&y;
# int function(void) __unused;
# void only_writes_to_buffer(char *__output buffer);
#
# In the .clang-format configuration file, this can be configured like:
# 
# AttributeMacros: [__capability, __output, __unused]
# ---------------------------------------
#>>>>>
 # AttributeMacros: 


#` BinPackArguments (Boolean) clang-format 3.7 ¶
# If false, a function call’s arguments will either be all on the same line or will have one line each.
# 
# true:
# void f() {
#   f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,
#     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);
# }
# 
# false:
# void f() {
#   f(aaaaaaaaaaaaaaaaaaaa,
#     aaaaaaaaaaaaaaaaaaaa,
#     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);
# }
# ---------------------------------------
#>>>>>
# The following affects elements between the braces in array initialization 
BinPackArguments: true


#` BinPackLongBracedList (Boolean) clang-format 21 ¶    !!!!!***NOT USED***  beyond clang-format 19
# If BinPackLongBracedList is true it overrides BinPackArguments if there are 20 or more items in a braced initializer list.
# 
# BinPackLongBracedList: false  vs.    BinPackLongBracedList: true
# vector<int> x{                       vector<int> x{1, 2, ...,
#                                                    20, 21};
#             1,
#             2,
#             ...,
#             20,
#             21};
# ---------------------------------------
#>>>>>
 # BinPackLongBracedList: false


# The following is what the Clang 21.0.0git documentation says
#
#` BinPackParameters (BinPackParametersStyle) clang-format 3.7 ¶    !!!!!***NOT USED***  This is actually incorrect.
# The bin pack parameters style to use.
# ---------------------------------------
 
# BPPS_BinPack (in configuration: BinPack) Bin-pack parameters.
# 
# void f(int a, int bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,
#        int ccccccccccccccccccccccccccccccccccccccccccc);
# ---------------------------------------

# BPPS_OnePerLine (in configuration: OnePerLine) Put all parameters on the current line if they fit. Otherwise, put each one on its own line.
# 
# void f(int a, int b, int c);
# 
# void f(int a,
#        int b,
#        int ccccccccccccccccccccccccccccccccccccc);
# ---------------------------------------

# BPPS_AlwaysOnePerLine (in configuration: AlwaysOnePerLine) Always put each parameter on its own line.
# 
# void f(int a,
#        int b,
#        int c);
# ---------------------------------------
#>>>>>
 # BinPackParameters: AlwaysOnePerLine


# BUT this is what it is (per Clang 18.0.0git documentation)
#
#` BinPackParameters (Boolean) clang-format 3.7 ¶
# If false, a function declaration’s or function definition’s parameters will either all be on the same line or will have one line each.
# 
# true:
# void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,
#        int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}
# 
# false:
# void f(int aaaaaaaaaaaaaaaaaaaa,
#        int aaaaaaaaaaaaaaaaaaaa,
#        int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}
# ---------------------------------------
#>>>>>
BinPackParameters: false


#` BitFieldColonSpacing (BitFieldColonSpacingStyle) clang-format 12 ¶
# The BitFieldColonSpacingStyle to use for bitfields.
# ---------------------------------------

# BFCS_Both (in configuration: Both) Add one space on each side of the :
# 
# unsigned bf : 2;
# ---------------------------------------

# BFCS_None (in configuration: None) Add no space around the : (except when needed for AlignConsecutiveBitFields).
# 
# unsigned bf:2;
# ---------------------------------------

# BFCS_Before (in configuration: Before) Add space before the : only
# 
# unsigned bf :2;
# ---------------------------------------

# BFCS_After (in configuration: After) Add space after the : only (space may be added before if needed for AlignConsecutiveBitFields).
# 
# unsigned bf: 2;
# ---------------------------------------
#>>>>>
BitFieldColonSpacing: Both


#` BraceWrapping (BraceWrappingFlags) clang-format 3.8 ¶    !!!!!<<<---IMPORTANT--->>>
# Control of individual brace wrapping cases.
# 
# If BreakBeforeBraces is set to Custom, use this to specify how each individual brace case should be handled. Otherwise, this is ignored.
# 
# Example of usage:
#
# BreakBeforeBraces: Custom
# BraceWrapping:
#   AfterEnum: true
#   AfterStruct: false
#   SplitEmptyFunction: false
# ---------------------------------------

# Nested configuration flags:
# 
# Precise control over the wrapping of braces.
# 
# Should be declared this way:
#
# BreakBeforeBraces: Custom
# BraceWrapping:
#     AfterClass: true
# ---------------------------------------

# bool AfterCaseLabel Wrap case labels.
# 
# false:                                true:
# switch (foo) {                vs.     switch (foo) {
#   case 1: {                             case 1:
#     bar();                              {
#     break;                                bar();
#   }                                       break;
#   default: {                            }
#     plop();                             default:
#   }                                     {
# }                                         plop();
#                                         }
#                                       }
# ---------------------------------------

# bool AfterClass Wrap class definitions.
# 
# true:
# class foo
# {};
# 
# false:
# class foo {};
# ---------------------------------------

#` AfterControlStatement (BraceWrappingAfterControlStatementStyle) Wrap control statements (if/for/while/switch/..).
#  The above line is correct.  It differs from the following line taken from the Clang documentation, which is incorrect.
#    BraceWrappingAfterControlStatementStyle AfterControlStatement Wrap control statements (if/for/while/switch/..).
# ---------------------------------------
 
  # BWACS_Never (in configuration: Never) Never wrap braces after a control statement.
  # 
  # if (foo()) {
  # } else {
  # }
  # for (int i = 0; i < 10; ++i) {
  # }
  # ---------------------------------------

  # BWACS_MultiLine (in configuration: MultiLine) Only wrap braces after a multi-line control statement.
  # 
  # if (foo && bar &&
  #     baz)
  # {
  #   quux();
  # }
  # while (foo || bar) {
  # }
  # ---------------------------------------

  # BWACS_Always (in configuration: Always) Always wrap braces after a control statement.
  # 
  # if (foo())
  # {
  # } else
  # {}
  # for (int i = 0; i < 10; ++i)
  # {}  
  # --------------------------------------- 
#>>>>>  
  
# bool AfterEnum Wrap enum definitions.
# 
# true:
# enum X : int
# {
#   B
# };
# 
# false:
# enum X : int { B };
# ---------------------------------------

# bool AfterFunction Wrap function definitions.
# 
# true:
# void foo()
# {
#   bar();
#   bar2();
# }
# 
# false:
# void foo() {
#   bar();
#   bar2();
# }
# ---------------------------------------

# bool AfterNamespace Wrap namespace definitions.
# 
# true:
# namespace
# {
# int foo();
# int bar();
# }
# 
# false:
# namespace {
# int foo();
# int bar();
# }
# ---------------------------------------

# bool AfterObjCDeclaration Wrap ObjC definitions (interfaces, implementations…).
# Note
# @autoreleasepool and @synchronized blocks are wrapped according to AfterControlStatement flag.
# ---------------------------------------

# bool AfterStruct Wrap struct definitions.
# 
# true:
# struct foo
# {
#   int x;
# };
# 
# false:
# struct foo {
#   int x;
# };
# ---------------------------------------

# bool AfterUnion Wrap union definitions.
# 
# true:
# union foo
# {
#   int x;
# }
# 
# false:
# union foo {
#   int x;
# }
# ---------------------------------------

# bool AfterExternBlock Wrap extern blocks.
# 
# true:
# extern "C"
# {
#   int foo();
# }
# 
# false:
# extern "C" {
# int foo();
# }
# ---------------------------------------

# bool BeforeCatch Wrap before catch.
# 
# true:
# try {
#   foo();
# }
# catch () {
# }
# 
# false:
# try {
#   foo();
# } catch () {
# }
# ---------------------------------------

# bool BeforeElse Wrap before else.
# 
# true:
# if (foo()) {
# }
# else {
# }
# 
# false:
# if (foo()) {
# } else {
# }
# ---------------------------------------

# bool BeforeLambdaBody Wrap lambda block.
# 
# true:
# connect(
#   []()
#   {
#     foo();
#     bar();
#   });
# 
# false:
# connect([]() {
#   foo();
#   bar();
# });
# ---------------------------------------

# bool BeforeWhile Wrap before while.
# 
# true:
# do {
#   foo();
# }
# while (1);
# 
# false:
# do {
#   foo();
# } while (1);
# ---------------------------------------

# bool IndentBraces Indent the wrapped braces themselves.
# ---------------------------------------

# bool SplitEmptyFunction If false, empty function body can be put on a single line. This option is used only if the opening brace of the function has already been wrapped, i.e. the AfterFunction brace wrapping mode is set, and the function could/should not be put on a single line (as per AllowShortFunctionsOnASingleLine and constructor formatting options).
# 
# false:          true:
# int f()   vs.   int f()
# {}              {
#                 }
# ---------------------------------------

# bool SplitEmptyRecord If false, empty record (e.g. class, struct or union) body can be put on a single line. This option is used only if the opening brace of the record has already been wrapped, i.e. the AfterClass (for classes) brace wrapping mode is set.
# 
# false:           true:
# class Foo   vs.  class Foo
# {}               {
#                  }
# ---------------------------------------

# bool SplitEmptyNamespace If false, empty namespace body can be put on a single line. This option is used only if the opening brace of the namespace has already been wrapped, i.e. the AfterNamespace brace wrapping mode is set.
# 
# false:               true:
# namespace Foo   vs.  namespace Foo
# {}                   {
#                      }
# ---------------------------------------
#>>>>>
# TODO not sure what to do with AfterObjCDeclaration
#
 # !_NOTE_! Setting these properly is key to getting the Allman, GNU and ACFS styles.
#           The IndentBraces, BeforeWhile, and BeforeLambdaBody sub options are the most important distinguishers between Allman and GNU styles.
# Specifically:
#   For Allman  - set these to "true / Always" except set BeforeWhile: and IndentBraces: to false
#     Like so:
#       BeforeLambdaBody: true
#       BeforeWhile:      false
#       IndentBraces:     false
#
#   For GNU     - set these to "true / Always" except set BeforeLambdaBody: to false
#     Like so:
#       BeforeLambdaBody: false
#       BeforeWhile:      true
#       IndentBraces:     true
#
 # !_NOTE_! ACFS is a combines elements of Allman and GNU
#
#   For ACFS    - set these to "true / Always" except set SplitEmptyFunction:, SplitEmptyRecord:, and SplitEmptyNamespace: to false
#     Like so:
#       BeforeLambdaBody: true      like Allman
#       BeforeWhile:      true      like GNU
#       IndentBraces:     true      like GNU
#       SplitEmptyFunction:  false
#       SplitEmptyRecord:    false
#       SplitEmptyNamespace: false
BraceWrapping:
  AfterCaseLabel: true
  AfterClass: true
  AfterControlStatement:  Always
  AfterEnum: true
  AfterFunction: true
  AfterNamespace: true
  AfterObjCDeclaration: true
  AfterStruct: true
  AfterUnion: true
  AfterExternBlock: true
  BeforeCatch: true
  BeforeElse: true
  BeforeLambdaBody: true
  BeforeWhile: true
  IndentBraces: true
  SplitEmptyFunction: false
  SplitEmptyRecord: false
  SplitEmptyNamespace: false


#` BracedInitializerIndentWidth (Unsigned) clang-format 17 ¶
# The number of columns to use to indent the contents of braced init lists. If unset, ContinuationIndentWidth is used.
# 
# AlignAfterOpenBracket: AlwaysBreak
# BracedInitializerIndentWidth: 2
# 
# void f() {
#   SomeClass c{
#     "foo",
#     "bar",
#     "baz",
#   };
#   auto s = SomeStruct{
#     .foo = "foo",
#     .bar = "bar",
#     .baz = "baz",
#   };
#   SomeArrayT a[3] = {
#     {
#       foo,
#       bar,
#     },
#     {
#       foo,
#       bar,
#     },
#     SomeArrayT{},
#   };
# }
# ---------------------------------------
#>>>>>
BracedInitializerIndentWidth: 2


#` BreakAdjacentStringLiterals (Boolean) clang-format 18 ¶
# Break between adjacent string literals.
# 
# true:
# return "Code"
#        "\0\52\26\55\55\0"
#        "x013"
#        "\02\xBA";
# false:
# return "Code" "\0\52\26\55\55\0" "x013" "\02\xBA";
# ---------------------------------------
#>>>>>
BreakAdjacentStringLiterals: true


#` BreakAfterAttributes (AttributeBreakingStyle) clang-format 16 ¶
# Break after a group of C++11 attributes before variable or function (including constructor/destructor) declaration/definition names or before control statements, i.e. if, switch (including case and default labels), for, and while statements.
# ---------------------------------------

# ABS_Always (in configuration: Always) Always break after attributes.
# 
# [[maybe_unused]]
# const int i;
# [[gnu::const]] [[maybe_unused]]
# int j;
# 
# [[nodiscard]]
# inline int f();
# [[gnu::const]] [[nodiscard]]
# int g();
# 
# [[likely]]
# if (a)
#   f();
# else
#   g();
# 
# switch (b) {
# [[unlikely]]
# case 1:
#   ++b;
#   break;
# [[likely]]
# default:
#   return;
# }
# ---------------------------------------

# ABS_Leave (in configuration: Leave) Leave the line breaking after attributes as is.
# 
# [[maybe_unused]] const int i;
# [[gnu::const]] [[maybe_unused]]
# int j;
# 
# [[nodiscard]] inline int f();
# [[gnu::const]] [[nodiscard]]
# int g();
# 
# [[likely]] if (a)
#   f();
# else
#   g();
# 
# switch (b) {
# [[unlikely]] case 1:
#   ++b;
#   break;
# [[likely]]
# default:
#   return;
# }
# ---------------------------------------

# ABS_Never (in configuration: Never) Never break after attributes.
# 
# [[maybe_unused]] const int i;
# [[gnu::const]] [[maybe_unused]] int j;
# 
# [[nodiscard]] inline int f();
# [[gnu::const]] [[nodiscard]] int g();
# 
# [[likely]] if (a)
#   f();
# else
#   g();
# 
# switch (b) {
# [[unlikely]] case 1:
#   ++b;
#   break;
# [[likely]] default:
#   return;
# }
# ---------------------------------------
#>>>>>
BreakAfterAttributes: Leave


#` BreakAfterJavaFieldAnnotations (Boolean) clang-format 3.8 ¶    !!!!!***NOT USED***  For Java only
# Break after each annotation on a field in Java files.
# 
# true:                                  false:
# @Partial                       vs.     @Partial @Mock DataLoad loader;
# @Mock
# DataLoad loader;
# ---------------------------------------
#>>>>>
 # BreakAfterJavaFieldAnnotations: 

#` BreakAfterReturnType (ReturnTypeBreakingStyle) clang-format 19 ¶
# The function declaration return type breaking style to use.
# ---------------------------------------

# RTBS_None (in configuration: None) This is deprecated. See Automatic below.
# ---------------------------------------

# RTBS_Automatic (in configuration: Automatic) Break after return type based on PenaltyReturnTypeOnItsOwnLine.
# 
# class A {
#   int f() { return 0; };
# };
# int f();
# int f() { return 1; }
# int
# LongName::AnotherLongName();
# ---------------------------------------

# RTBS_ExceptShortType (in configuration: ExceptShortType) Same as Automatic above, except that there is no break after short return types.
# 
# class A {
#   int f() { return 0; };
# };
# int f();
# int f() { return 1; }
# int LongName::
#     AnotherLongName();
# ---------------------------------------

# RTBS_All (in configuration: All) Always break after the return type.
# 
# class A {
#   int
#   f() {
#     return 0;
#   };
# };
# int
# f();
# int
# f() {
#   return 1;
# }
# int
# LongName::AnotherLongName();
# ---------------------------------------

# RTBS_TopLevel (in configuration: TopLevel) Always break after the return types of top-level functions.
# 
# class A {
#   int f() { return 0; };
# };
# int
# f();
# int
# f() {
#   return 1;
# }
# int
# LongName::AnotherLongName();
# ---------------------------------------

# RTBS_AllDefinitions (in configuration: AllDefinitions) Always break after the return type of function definitions.
# 
# class A {
#   int
#   f() {
#     return 0;
#   };
# };
# int f();
# int
# f() {
#   return 1;
# }
# int
# LongName::AnotherLongName();
# ---------------------------------------

# RTBS_TopLevelDefinitions (in configuration: TopLevelDefinitions) Always break after the return type of top-level definitions.
# 
# class A {
#   int f() { return 0; };
# };
# int f();
# int
# f() {
#   return 1;
# }
# int
# LongName::AnotherLongName();
# ---------------------------------------
#>>>>>
# Using "None" even though it is deprecated
BreakAfterReturnType: None


#` BreakArrays (Boolean) clang-format 16 ¶
# If true, clang-format will always break after a Json array [ otherwise it will scan until the closing ] to determine if it should add newlines between elements (prettier compatible).
# 
# Note: 
# This is currently only for formatting JSON.
# 
# true:                                  false:
# [                          vs.      [1, 2, 3, 4]
#   1,
#   2,
#   3,
#   4
# ]
# ---------------------------------------
#>>>>>
BreakArrays: false


#` BreakBeforeBinaryOperators (BinaryOperatorStyle) clang-format 3.6 ¶
# The way to wrap binary operators.
# ---------------------------------------

# BOS_None (in configuration: None) Break after operators.
# 
# LooooooooooongType loooooooooooooooooooooongVariable =
#     someLooooooooooooooooongFunction();
# 
# bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +
#                      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==
#                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&
#              aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >
#                  ccccccccccccccccccccccccccccccccccccccccc;
# ---------------------------------------

# BOS_NonAssignment (in configuration: NonAssignment) Break before operators that aren’t assignments.
# 
# LooooooooooongType loooooooooooooooooooooongVariable =
#     someLooooooooooooooooongFunction();
# 
# bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#                      + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#                  == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#              && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#                     > ccccccccccccccccccccccccccccccccccccccccc;
# ---------------------------------------

# BOS_All (in configuration: All) Break before operators.
# 
# LooooooooooongType loooooooooooooooooooooongVariable
#     = someLooooooooooooooooongFunction();
# 
# bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#                      + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#                  == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#              && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
#                     > ccccccccccccccccccccccccccccccccccccccccc;
# ---------------------------------------
#>>>>>
BreakBeforeBinaryOperators: None


#` BreakBeforeBraces (BraceBreakingStyle) clang-format 3.7 ¶    !!!!!<<<---IMPORTANT--->>>
# The brace breaking style to use.
# ---------------------------------------

# BS_Attach (in configuration: Attach) Always attach braces to surrounding context.
# 
# namespace N {
# enum E {
#   E1,
#   E2,
# };
# 
# class C {
# public:
#   C();
# };
# 
# bool baz(int i) {
#   try {
#     do {
#       switch (i) {
#       case 1: {
#         foobar();
#         break;
#       }
#       default: {
#         break;
#       }
#       }
#     } while (--i);
#     return true;
#   } catch (...) {
#     handleError();
#     return false;
#   }
# }
# 
# void foo(bool b) {
#   if (b) {
#     baz(2);
#   } else {
#     baz(5);
#   }
# }
# 
# void bar() { foo(true); }
# } // namespace N
# ---------------------------------------

# BS_Linux (in configuration: Linux) Like Attach, but break before braces on function, namespace and class definitions.
# 
# namespace N
# {
# enum E {
#   E1,
#   E2,
# };
# 
# class C
# {
# public:
#   C();
# };
# 
# bool baz(int i)
# {
#   try {
#     do {
#       switch (i) {
#       case 1: {
#         foobar();
#         break;
#       }
#       default: {
#         break;
#       }
#       }
#     } while (--i);
#     return true;
#   } catch (...) {
#     handleError();
#     return false;
#   }
# }
# 
# void foo(bool b)
# {
#   if (b) {
#     baz(2);
#   } else {
#     baz(5);
#   }
# }
# 
# void bar() { foo(true); }
# } // namespace N
# ---------------------------------------

# BS_Mozilla (in configuration: Mozilla) Like Attach, but break before braces on enum, function, and record definitions.
# 
# namespace N {
# enum E
# {
#   E1,
#   E2,
# };
# 
# class C
# {
# public:
#   C();
# };
# 
# bool baz(int i)
# {
#   try {
#     do {
#       switch (i) {
#       case 1: {
#         foobar();
#         break;
#       }
#       default: {
#         break;
#       }
#       }
#     } while (--i);
#     return true;
#   } catch (...) {
#     handleError();
#     return false;
#   }
# }
# 
# void foo(bool b)
# {
#   if (b) {
#     baz(2);
#   } else {
#     baz(5);
#   }
# }
# 
# void bar() { foo(true); }
# } // namespace N
# ---------------------------------------

# BS_Stroustrup (in configuration: Stroustrup) Like Attach, but break before function definitions, catch, and else.
# 
# namespace N {
# enum E {
#   E1,
#   E2,
# };
# 
# class C {
# public:
#   C();
# };
# 
# bool baz(int i)
# {
#   try {
#     do {
#       switch (i) {
#       case 1: {
#         foobar();
#         break;
#       }
#       default: {
#         break;
#       }
#       }
#     } while (--i);
#     return true;
#   }
#   catch (...) {
#     handleError();
#     return false;
#   }
# }
# 
# void foo(bool b)
# {
#   if (b) {
#     baz(2);
#   }
#   else {
#     baz(5);
#   }
# }
# 
# void bar() { foo(true); }
# } // namespace N
# ---------------------------------------

# BS_Allman (in configuration: Allman) Always break before braces.
# 
# namespace N
# {
# enum E
# {
#   E1,
#   E2,
# };
# 
# class C
# {
# public:
#   C();
# };
# 
# bool baz(int i)
# {
#   try
#   {
#     do
#     {
#       switch (i)
#       {
#       case 1:
#       {
#         foobar();
#         break;
#       }
#       default:
#       {
#         break;
#       }
#       }
#     } while (--i);
#     return true;
#   }
#   catch (...)
#   {
#     handleError();
#     return false;
#   }
# }
# 
# void foo(bool b)
# {
#   if (b)
#   {
#     baz(2);
#   }
#   else
#   {
#     baz(5);
#   }
# }
# 
# void bar() { foo(true); }
# } // namespace N
# ---------------------------------------

# BS_Whitesmiths (in configuration: Whitesmiths) Like Allman but always indent braces and line up code with braces.
# 
# namespace N
#   {
# enum E
#   {
#   E1,
#   E2,
#   };
# 
# class C
#   {
# public:
#   C();
#   };
# 
# bool baz(int i)
#   {
#   try
#     {
#     do
#       {
#       switch (i)
#         {
#         case 1:
#         {
#         foobar();
#         break;
#         }
#         default:
#         {
#         break;
#         }
#         }
#       } while (--i);
#     return true;
#     }
#   catch (...)
#     {
#     handleError();
#     return false;
#     }
#   }
# 
# void foo(bool b)
#   {
#   if (b)
#     {
#     baz(2);
#     }
#   else
#     {
#     baz(5);
#     }
#   }
# 
# void bar() { foo(true); }
#   } // namespace N
# ---------------------------------------

# BS_GNU (in configuration: GNU) Always break before braces and add an extra level of indentation to braces of control statements, not to those of class, function or other definitions.
# 
# namespace N
# {
# enum E
# {
#   E1,
#   E2,
# };
# 
# class C
# {
# public:
#   C();
# };
# 
# bool baz(int i)
# {
#   try
#     {
#       do
#         {
#           switch (i)
#             {
#             case 1:
#               {
#                 foobar();
#                 break;
#               }
#             default:
#               {
#                 break;
#               }
#             }
#         }
#       while (--i);
#       return true;
#     }
#   catch (...)
#     {
#       handleError();
#       return false;
#     }
# }
# 
# void foo(bool b)
# {
#   if (b)
#     {
#       baz(2);
#     }
#   else
#     {
#       baz(5);
#     }
# }
# 
# void bar() { foo(true); }
# } // namespace N
# ---------------------------------------

# BS_WebKit (in configuration: WebKit) Like Attach, but break before functions.
# 
# namespace N {
# enum E {
#   E1,
#   E2,
# };
# 
# class C {
# public:
#   C();
# };
# 
# bool baz(int i)
# {
#   try {
#     do {
#       switch (i) {
#       case 1: {
#         foobar();
#         break;
#       }
#       default: {
#         break;
#       }
#       }
#     } while (--i);
#     return true;
#   } catch (...) {
#     handleError();
#     return false;
#   }
# }
# 
# void foo(bool b)
# {
#   if (b) {
#     baz(2);
#   } else {
#     baz(5);
#   }
# }
# 
# void bar() { foo(true); }
# } // namespace N
# ---------------------------------------

# BS_Custom (in configuration: Custom) Configure each individual brace in BraceWrapping.
# ---------------------------------------
#>>>>>
#
 # !_NOTE_! BreakBeforeBraces: Attach provides the "One-True-Brace" (OTB) brace style which is a variant of the K&R brace indentation style.
#           BreakBeforeBraces: Stroustrup provides the closest to original K&R brace indentation style.  Specifically, it does not use a "cuddled else".
BreakBeforeBraces : Custom


#` BreakBeforeConceptDeclarations (BreakBeforeConceptDeclarationsStyle) clang-format 12 ¶
# The concept declaration style to use.
# ---------------------------------------

# BBCDS_Never (in configuration: Never) Keep the template declaration line together with concept.
# 
# template <typename T> concept C = ...;
# ---------------------------------------

# BBCDS_Allowed (in configuration: Allowed) Breaking between template declaration and concept is allowed. The actual behavior depends on the content and line breaking rules and penalties.
# ---------------------------------------

# BBCDS_Always (in configuration: Always) Always break before concept, putting it in the line after the template declaration.
# 
# template <typename T>
# concept C = ...;
# ---------------------------------------
#>>>>>
BreakBeforeConceptDeclarations: Always


#` BreakBeforeInlineASMColon (BreakBeforeInlineASMColonStyle) clang-format 16 ¶
# The inline ASM colon style to use.
# ---------------------------------------

# BBIAS_Never (in configuration: Never) No break before inline ASM colon.  <<<<< Never is the default
# 
# asm volatile("string", : : val);
# ---------------------------------------

# BBIAS_OnlyMultiline (in configuration: OnlyMultiline) Break before inline ASM colon if the line length is longer than column limit.
# 
# asm volatile("string", : : val);
# asm("cmoveq %1, %2, %[result]"
#     : [result] "=r"(result)
#     : "r"(test), "r"(new), "[result]"(old));
# ---------------------------------------

# BBIAS_Always (in configuration: Always) Always break before inline ASM colon.
# 
# asm volatile("string",
#              :
#              : val);
# ---------------------------------------
#>>>>>
BreakBeforeInlineASMColon: Never


#` BreakBeforeTemplateCloser (Boolean) clang-format 21 ¶    !!!!!***NOT USED***  beyond clang-format 19
# If true, break before a template closing bracket (>) when there is a line break after the matching opening bracket (<).
# 
# true:
# template <typename Foo, typename Bar>
# 
# template <typename Foo,
#           typename Bar>
# 
# template <
#     typename Foo,
#     typename Bar
# >
# 
# false:
# template <typename Foo, typename Bar>
# 
# template <typename Foo,
#           typename Bar>
# 
# template <
#     typename Foo,
#     typename Bar>
# ---------------------------------------
#>>>>> 
 # BreakBeforeTemplateCloser: true 


#` BreakBeforeTernaryOperators (Boolean) clang-format 3.7 ¶
# If true, ternary operators will be placed after line breaks.
# 
# true:
# veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription
#     ? firstValue
#     : SecondValueVeryVeryVeryVeryLong;
# 
# false:
# veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?
#     firstValue :
#     SecondValueVeryVeryVeryVeryLong; 
# ---------------------------------------
#>>>>>  
BreakBeforeTernaryOperators: true 


#` BreakBinaryOperations (BreakBinaryOperationsStyle) clang-format 20 ¶    !!!!!***NOT USED***  beyond clang-format 19
# The break binary operations style to use.
# ---------------------------------------

# BBO_Never (in configuration: Never) Don’t break binary operations
# 
# aaa + bbbb * ccccc - ddddd +
# eeeeeeeeeeeeeeee;
# ---------------------------------------

# BBO_OnePerLine (in configuration: OnePerLine) Binary operations will either be all on the same line, or each operation will have one line each.
# 
# aaa +
# bbbb *
# ccccc -
# ddddd +
# eeeeeeeeeeeeeeee;
# ---------------------------------------

# BBO_RespectPrecedence (in configuration: RespectPrecedence) Binary operations of a particular precedence that exceed the column limit will have one line each.
# 
# aaa +
# bbbb * ccccc -
# ddddd +
# eeeeeeeeeeeeeeee;
# ---------------------------------------
#>>>>>  
 # BreakBinaryOperations: Never


#` BreakConstructorInitializers (BreakConstructorInitializersStyle) clang-format 5 ¶
# The break constructor initializers style to use.
# ---------------------------------------

# BCIS_BeforeColon (in configuration: BeforeColon) Break constructor initializers before the colon and after the commas.
# 
# Constructor()
#     : initializer1(),
#       initializer2()
# ---------------------------------------

# BCIS_BeforeComma (in configuration: BeforeComma) Break constructor initializers before the colon and commas, and align the commas with the colon.
# 
# Constructor()
#     : initializer1()
#     , initializer2()
# ---------------------------------------

# BCIS_AfterColon (in configuration: AfterColon) Break constructor initializers after the colon and commas.
# 
# Constructor() :
#     initializer1(),
#     initializer2()
# ---------------------------------------
#>>>>>  
BreakConstructorInitializers: AfterColon


#` BreakFunctionDefinitionParameters (Boolean) clang-format 19 ¶
# If true, clang-format will always break before function definition parameters.
# 
# true:
# void functionDefinition(
#          int A, int B) {}
# 
# false:
# void functionDefinition(int A, int B) {}
# ---------------------------------------
#>>>>>  
BreakFunctionDefinitionParameters: false


#` BreakInheritanceList (BreakInheritanceListStyle) clang-format 7 ¶
# The inheritance list style to use.
# ---------------------------------------

# BILS_BeforeColon (in configuration: BeforeColon) Break inheritance list before the colon and after the commas.
# 
# class Foo
#     : Base1,
#       Base2
# {};
# ---------------------------------------

# BILS_BeforeComma (in configuration: BeforeComma) Break inheritance list before the colon and commas, and align the commas with the colon.
# 
# class Foo
#     : Base1
#     , Base2
# {};
# ---------------------------------------

# BILS_AfterColon (in configuration: AfterColon) Break inheritance list after the colon and commas.  <<<<< AfterColon is the default
# 
# class Foo :
#     Base1,
#     Base2
# {};
# ---------------------------------------

# BILS_AfterComma (in configuration: AfterComma) Break inheritance list only after the commas.
# 
# class Foo : Base1,
#             Base2
# {};
# ---------------------------------------
#>>>>>  
BreakInheritanceList: AfterColon


#` BreakStringLiterals (Boolean) clang-format 3.9 ¶ 
# Allow breaking string literals when formatting.  <<<<< Default is true
# ---------------------------------------
 
# In C, C++, and Objective-C:
# 
# true:
# const char* x = "veryVeryVeryVeryVeryVe"
#                 "ryVeryVeryVeryVeryVery"
#                 "VeryLongString";
# 
# false:
# const char* x =
#     "veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString";
# ---------------------------------------

# In C# and Java:
# 
# true:
# string x = "veryVeryVeryVeryVeryVe" +
#            "ryVeryVeryVeryVeryVery" +
#            "VeryLongString";
# 
# false:
# string x =
#     "veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString";
#
# C# interpolated strings are not broken.
# ---------------------------------------

# In Verilog:
# 
# true:
# string x = {"veryVeryVeryVeryVeryVe",
#             "ryVeryVeryVeryVeryVery",
#             "VeryLongString"};
# 
# false:
# string x =
#     "veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString";
# ---------------------------------------
#>>>>>  
 # !_NOTE_! BreakStringLiterals: true will break long string literals across multiple lines to satisfy the column limit.
#           The default is true but it has no effect when setting ColumnLimit: 0 (infinite column width(
BreakStringLiterals: false


#` BreakTemplateDeclarations (BreakTemplateDeclarationsStyle) clang-format 19 ¶
# The template declaration breaking style to use.
# ---------------------------------------

# BTDS_Leave (in configuration: Leave) Do not change the line breaking before the declaration.
# 
# template <typename T>
# T foo() {
# }
# template <typename T> T foo(int aaaaaaaaaaaaaaaaaaaaa,
#                             int bbbbbbbbbbbbbbbbbbbbb) {
# }
# ---------------------------------------

# BTDS_No (in configuration: No) Do not force break before declaration. PenaltyBreakTemplateDeclaration is taken into account.
# 
# template <typename T> T foo() {
# }
# template <typename T> T foo(int aaaaaaaaaaaaaaaaaaaaa,
#                             int bbbbbbbbbbbbbbbbbbbbb) {
# }
# ---------------------------------------

# BTDS_MultiLine (in configuration: MultiLine) Force break after template declaration only when the following declaration spans multiple lines.
# 
# template <typename T> T foo() {
# }
# template <typename T>
# T foo(int aaaaaaaaaaaaaaaaaaaaa,
#       int bbbbbbbbbbbbbbbbbbbbb) {
# }
# ---------------------------------------

# BTDS_Yes (in configuration: Yes) Always break after template declaration.
# 
# template <typename T>
# T foo() {
# }
# template <typename T>
# T foo(int aaaaaaaaaaaaaaaaaaaaa,
#       int bbbbbbbbbbbbbbbbbbbbb) {
# }
# ---------------------------------------
#>>>>>  
BreakTemplateDeclarations: Yes


#` ColumnLimit (Unsigned) clang-format 3.7 ¶
# The column limit.
# 
# A column limit of 0 means that there is no column limit. In this case, clang-format will respect the input’s line breaking decisions within statements unless they contradict other rules.
# ---------------------------------------
#>>>>>  
ColumnLimit: 0


#` CommentPragmas (String) clang-format 3.7 ¶    !!!!!***NOT USED***  (regular expression String)
# A regular expression that describes comments with special meaning, which should not be split into lines or otherwise changed.
# 
# // CommentPragmas: '^ FOOBAR pragma:'
# // Will leave the following line unaffected
# #include <vector> // FOOBAR pragma: keep
# ---------------------------------------
#>>>>>  
 # !_NOTE_! Example:  CommentPragmas: "^DO_NOT_SPLIT_COMMENT"
#                     Which means any comment line starting with "DO_NOT_SPLIT_COMMENT" will be considered a special comment that will not be formatted.
 # CommentPragmas: 


#` CompactNamespaces (Boolean) clang-format 5 ¶
# If true, consecutive namespace declarations will be on the same line. If false, each namespace is declared on a new line.
# 
# true:
# namespace Foo { namespace Bar {
# }}
# 
# false:  <<<<< Default is false
# namespace Foo {
# namespace Bar {
# }
# }
# If it does not fit on a single line, the overflowing namespaces get wrapped:
# 
# namespace Foo { namespace Bar {
# namespace Extra {
# }}}
# ---------------------------------------
#>>>>>  
CompactNamespaces: false


#` ConstructorInitializerAllOnOneLineOrOnePerLine (Boolean) clang-format 3.7 ¶    !!!!!***NOT USED***  deprecated - See CurrentLine of PackConstructorInitializers
# This option is deprecated. See CurrentLine of PackConstructorInitializers.
# ---------------------------------------
#>>>>>  
 # ConstructorInitializerAllOnOneLineOrOnePerLine: 


#` ConstructorInitializerIndentWidth (Unsigned) clang-format 3.7 ¶
# The number of characters to use for indentation of constructor initializer lists as well as inheritance lists.
# ---------------------------------------
#>>>>>  
ConstructorInitializerIndentWidth: 2


#` ContinuationIndentWidth (Unsigned) clang-format 3.7 ¶
# Indent width for line continuations.
# 
# ContinuationIndentWidth: 2
# 
# int i =         //  VeryVeryVeryVeryVeryLongComment
#   longFunction( // Again a long comment
#     arg);
# ---------------------------------------
#>>>>>  
ContinuationIndentWidth: 2


#` Cpp11BracedListStyle (Boolean) clang-format 3.4 ¶ 
# If true, format braced lists as best suited for C++11 braced lists.
# 
# Important differences:
# 
# No spaces inside the braced list.
# No line break before the closing brace.
# Indentation with the continuation indent, not with the block indent.
# 
# Fundamentally, C++11 braced lists are formatted exactly like function calls would be formatted in their place. If the braced list follows a name (e.g. a type or variable name), clang-format formats as if the {} were the parentheses of a function call with that name. If there is no name, a zero-length name is assumed.
# 
# true:                                  false:
# vector<int> x{1, 2, 3, 4};     vs.     vector<int> x{ 1, 2, 3, 4 };
# vector<T> x{{}, {}, {}, {}};           vector<T> x{ {}, {}, {}, {} };
# f(MyMap[{composite, key}]);            f(MyMap[{ composite, key }]);
# new int[3]{1, 2, 3};                   new int[3]{ 1, 2, 3 };
# ---------------------------------------
#>>>>>
Cpp11BracedListStyle: false 


# DeriveLineEnding (Boolean) clang-format 10 ¶    !!!!!***NOT USED***   deprecated - See DeriveLF and DeriveCRLF of LineEnding.
# This option is deprecated. See DeriveLF and DeriveCRLF of LineEnding.
# ---------------------------------------
#>>>>>
 # DeriveLineEnding: 


# DerivePointerAlignment (Boolean) clang-format 3.7 ¶
# If true, analyze the formatted file for the most common alignment of & and *. Pointer and reference alignment styles are going to be updated according to the preferences found in the file. PointerAlignment is then used only as fallback.
# ---------------------------------------
#>>>>>
DerivePointerAlignment: false


# DisableFormat (Boolean) clang-format 3.7 ¶    !!!!!***NOT USED***  Use to turn off the entire .clang-format file
# Disables formatting completely.
# ---------------------------------------
#>>>>>
 # DisableFormat: 


#` EmptyLineAfterAccessModifier (EmptyLineAfterAccessModifierStyle) clang-format 13 ¶
# Defines when to put an empty line after access modifiers. EmptyLineBeforeAccessModifier configuration handles the number of empty lines between two access modifiers.
# ---------------------------------------

# ELAAMS_Never (in configuration: Never) Remove all empty lines after access modifiers.
# 
# struct foo {
# private:
#   int i;
# protected:
#   int j;
#   /* comment */
# public:
#   foo() {}
# private:
# protected:
# };
# ---------------------------------------

# ELAAMS_Leave (in configuration: Leave) Keep existing empty lines after access modifiers. MaxEmptyLinesToKeep is applied instead.
# 
# ---------------------------------------

# ELAAMS_Always (in configuration: Always) Always add empty line after access modifiers if there are none. MaxEmptyLinesToKeep is applied also.
# 
# struct foo {
# private:
# 
#   int i;
# protected:
# 
#   int j;
#   /* comment */
# public:
# 
#   foo() {}
# private:
# 
# protected:
# 
# };
# ---------------------------------------
#>>>>>
EmptyLineAfterAccessModifier: Always


#` EmptyLineBeforeAccessModifier (EmptyLineBeforeAccessModifierStyle) clang-format 12 ¶
# Defines in which cases to put empty line before access modifiers.
# ---------------------------------------

# ELBAMS_Never (in configuration: Never) Remove all empty lines before access modifiers.
# 
# struct foo {
# private:
#   int i;
# protected:
#   int j;
#   /* comment */
# public:
#   foo() {}
# private:
# protected:
# };
# ---------------------------------------

# ELBAMS_Leave (in configuration: Leave) Keep existing empty lines before access modifiers.
# 
# ---------------------------------------

# ELBAMS_LogicalBlock (in configuration: LogicalBlock) Add empty line only when access modifier starts a new logical block. Logical block is a group of one or more member fields or functions.
# 
# struct foo {
# private:
#   int i;
# 
# protected:
#   int j;
#   /* comment */
# public:
#   foo() {}
# 
# private:
# protected:
# };
# ---------------------------------------

# ELBAMS_Always (in configuration: Always) Always add empty line before access modifiers unless access modifier is at the start of struct or class definition.
# 
# struct foo {
# private:
#   int i;
# 
# protected:
#   int j;
#   /* comment */
# 
# public:
#   foo() {}
# 
# private:
# 
# protected:
# };
# ---------------------------------------
#>>>>>
EmptyLineBeforeAccessModifier: Always


#` ExperimentalAutoDetectBinPacking (Boolean) clang-format 3.7 ¶    !!!!!***NOT USED***  Experimental
# If true, clang-format detects whether function calls and definitions are formatted with one parameter per line.
# 
# Each call can be bin-packed, one-per-line or inconclusive. If it is inconclusive, e.g. completely on one line, but a decision needs to be made, clang-format analyzes whether there are other bin-packed cases in the input file and act accordingly.
# 
# Note:
# This is an experimental flag, that might go away or be renamed. Do not use this in config files, etc. Use at your own risk.
# ---------------------------------------
#>>>>>
 # ExperimentalAutoDetectBinPacking: 


#` FixNamespaceComments (Boolean) clang-format 5 ¶
# If true, clang-format adds missing namespace end comments for namespaces and fixes invalid existing ones. This doesn’t affect short namespaces, which are controlled by ShortNamespaceLines.
# 
# true:                                  false:  <<<<< False is the default
# namespace longNamespace {      vs.     namespace longNamespace {
# void foo();                            void foo();
# void bar();                            void bar();
# } // namespace a                       }
# namespace shortNamespace {             namespace shortNamespace {
# void baz();                            void baz();
# }                                      }
# ---------------------------------------
#>>>>>
FixNamespaceComments: false


#` ForEachMacros (List of Strings) clang-format 3.7 ¶    !!!!!***NOT USED***  (List of Strings)
# A vector of macros that should be interpreted as foreach loops instead of as function calls.
# 
# These are expected to be macros of the form:
# 
# FOREACH(<variable-declaration>, ...)
#   <loop-body>
# In the .clang-format configuration file, this can be configured like:
# 
# ForEachMacros: [RANGES_FOR, FOREACH]
# For example: BOOST_FOREACH.
# ---------------------------------------
#>>>>>
 # ForEachMacros: 


#` IfMacros (List of Strings) clang-format 13 ¶    !!!!!***NOT USED***  (List of Strings)
# A vector of macros that should be interpreted as foreach loops instead of as function calls.
# 
# These are expected to be macros of the form:
# 
# FOREACH(<variable-declaration>, ...)
#   <loop-body>
# In the .clang-format configuration file, this can be configured like:
# 
# ForEachMacros: [RANGES_FOR, FOREACH]
# For example: BOOST_FOREACH.
# ---------------------------------------
#>>>>>
 # ForEachMacros: 
# A vector of macros that should be interpreted as conditionals instead of as function calls.
# 
# These are expected to be macros of the form:
# 
# IF(...)
#   <conditional-body>
# else IF(...)
#   <conditional-body>
# In the .clang-format configuration file, this can be configured like:
# 
# IfMacros: [IF]
# For example: KJ_IF_MAYBE
# ---------------------------------------
#>>>>>
 # IfMacros: 


#` IncludeBlocks (IncludeBlocksStyle) clang-format 6 ¶
# Dependent on the value, multiple #include blocks can be sorted as one and divided based on category.
# 
# Possible values:
# 
# IBS_Preserve (in configuration: Preserve) Sort each #include block separately.
# 
# #include "b.h"               into      #include "b.h"
# 
# #include <lib/main.h>                  #include "a.h"
# #include "a.h"                         #include <lib/main.h>
# ---------------------------------------

# IBS_Merge (in configuration: Merge) Merge multiple #include blocks together and sort as one.
# 
# #include "b.h"               into      #include "a.h"
#                                        #include "b.h"
# #include <lib/main.h>                  #include <lib/main.h>
# #include "a.h"
# ---------------------------------------

# IBS_Regroup (in configuration: Regroup) Merge multiple #include blocks together and sort as one. Then split into groups based on category priority. See IncludeCategories.
# 
# #include "b.h"               into      #include "a.h"
#                                        #include "b.h"
# #include <lib/main.h>
# #include "a.h"                         #include <lib/main.h>
# ---------------------------------------
#>>>>>
 # !_NOTE_! When SortIncludes: Never then IncludeBlocks: has no effect 
 #          Not sure what the default value is for IncludeBlocks
IncludeBlocks: Preserve


#` IncludeCategories (List of IncludeCategories) clang-format 3.8 ¶    !!!!!***NOT USED***  a (regex List of IncludeCategories)
# Regular expressions denoting the different #include categories used for ordering #includes.
# 
# POSIX extended regular expressions are supported.
# 
# These regular expressions are matched against the filename of an include (including the <> or “”) in order. The value belonging to the first matching regular expression is assigned and #includes are sorted first according to increasing category number and then alphabetically within each category.
# 
# If none of the regular expressions match, INT_MAX is assigned as category. The main header for a source file automatically gets category 0. so that it is generally kept at the beginning of the #includes (https://llvm.org/docs/CodingStandards.html#include-style). However, you can also assign negative priorities if you have certain headers that always need to be first.
# 
# There is a third and optional field SortPriority which can used while IncludeBlocks = IBS_Regroup to define the priority in which #includes should be ordered. The value of Priority defines the order of #include blocks and also allows the grouping of #includes of different priority. SortPriority is set to the value of Priority as default if it is not assigned.
# 
# Each regular expression can be marked as case sensitive with the field CaseSensitive, per default it is not.
# 
# To configure this in the .clang-format file, use:
# 
# IncludeCategories:
#   - Regex:           '^"(llvm|llvm-c|clang|clang-c)/'
#     Priority:        2
#     SortPriority:    2
#     CaseSensitive:   true
#   - Regex:           '^((<|")(gtest|gmock|isl|json)/)'
#     Priority:        3
#   - Regex:           '<[[:alnum:].]+>'
#     Priority:        4
#   - Regex:           '.*'
#     Priority:        1
#     SortPriority:    0
# ---------------------------------------
#>>>>>
 # IncludeCategories: 


#` IncludeIsMainRegex (String) clang-format 3.9 ¶    !!!!!***NOT USED***  (regex String)
# Specify a regular expression of suffixes that are allowed in the file-to-main-include mapping.
# 
# When guessing whether a #include is the “main” include (to assign category 0, see above), use this regex of allowed suffixes to the header stem. A partial match is done, so that: * "" means “arbitrary suffix” * "$" means “no suffix”
# 
# For example, if configured to "(_test)?$", then a header a.h would be seen as the “main” include in both a.cc and a_test.cc.
# ---------------------------------------
#>>>>>
 # IncludeIsMainRegex: 


#` IncludeIsMainSourceRegex (String) clang-format 10 ¶    !!!!!***NOT USED***  (regex String)
# Specify a regular expression for files being formatted that are allowed to be considered “main” in the file-to-main-include mapping.
# 
# By default, clang-format considers files as “main” only when they end with: .c, .cc, .cpp, .c++, .cxx, .m or .mm extensions. For these files a guessing of “main” include takes place (to assign category 0, see above). This config option allows for additional suffixes and extensions for files to be considered as “main”.
# 
# For example, if this option is configured to (Impl\.hpp)$, then a file ClassImpl.hpp is considered “main” (in addition to Class.c, Class.cc, Class.cpp and so on) and “main include file” logic will be executed (with IncludeIsMainRegex setting also being respected in later phase). Without this option set, ClassImpl.hpp would not have the main include file put on top before any other include.
# ---------------------------------------
#>>>>>
 # IncludeIsMainSourceRegex: 


#` IndentAccessModifiers (Boolean) clang-format 13 ¶
# Specify whether access modifiers should have their own indentation level.
# 
# When false, access modifiers are indented (or outdented) relative to the record members, respecting the AccessModifierOffset. Record members are indented one level below the record. When true, access modifiers get their own indentation level. As a consequence, record members are always indented 2 levels below the record, regardless of the access modifier presence. Value of the AccessModifierOffset is ignored.
# 
# false:                                 true:
# class C {                      vs.     class C {
#   class D {                                class D {
#     void bar();                                void bar();
#   protected:                                 protected:
#     D();                                       D();
#   };                                       };
# public:                                  public:
#   C();                                     C();
# };                                     };
# void foo() {                           void foo() {
#   return 1;                              return 1;
# }                                      }
# ---------------------------------------
#>>>>>
 # !_NOTE_! IndentAccessModifiers and AccessModifierOffset apply to both classes and structs.  
 #
 #  - Setting IndentAccessModifiers: true will cause class and struct Access Modifiers to be indented by IndentWidth 
 #      and the subsequent code to indented by a further IndentWidth.  AccessModifierOffset: values will be IGNORED!
 #      - In clang-format v19, there is a side-effect.  The code in a struct is public by default so it is
 #          common to NOT have Access Modifiers in a struct definition.  However, setting IndentAccessModifiers: true
 #          will cause the code in a struct without any Access Modifiers to still be indented by 2 x IndentWidth!
 #          This means it is currently better to set IndentAccessModifiers: false and control the indentation for
 #          Access Modifiers via the AccessModifierOffset option, as explained next.
 #
 #  - Setting IndentAccessModifiers: false will enable use of AccessModifierOffset.
 #      The AccessModifierOffset does not affect the indentation of the code inside a class or struct.
 #      - Setting AccessModifierOffset: 0 will cause class and struct Access Modifiers to have the same Indentation
 #          as the subsequent code.
 #      - Setting AccessModifierOffset: 2 will cause class and struct Access Modifiers to have +2 spaces extra indentation
 #          compared to the subsequent code.
IndentAccessModifiers: false


#` IndentCaseBlocks (Boolean) clang-format 11 ¶
# Indent case label blocks one level from the case label.
# 
# When false, the block following the case label uses the same indentation level as for the case label, treating the case label the same as an if-statement. When true, the block gets indented as a scope block.
# 
# false:                                 true:
# switch (fool) {                vs.     switch (fool) {
# case 1: {                              case 1:
#   bar();                                 {
# } break;                                   bar();
# default: {                               }
#   plop();                                break;
# }                                      default:
# }                                        {
#                                            plop();
#                                          }
#                                        }
# ---------------------------------------
#>>>>>
 # !_NOTE_! IndentCaseBlocks: true is key to getting the ACFS style (Allman and GNU both set to false)
IndentCaseBlocks: true


#` IndentCaseLabels (Boolean) clang-format 3.3 ¶
# Indent case labels one level from the switch statement.
# 
# When false, use the same indentation level as for the switch statement. Switch statement body is always indented one level more than case labels (except the first block following the case label, which itself indents the code - unless IndentCaseBlocks is enabled).
# 
# false:                                 true:
# switch (fool) {                vs.     switch (fool) {
# case 1:                                  case 1:
#   bar();                                   bar();
#   break;                                   break;
# default:                                 default:
#   plop();                                  plop();
# }                                      }
# ---------------------------------------
#>>>>>
 # !_NOTE_! IndentCaseLabels: true is key to getting the ACFS style (Allman and GNU both set to false)
IndentCaseLabels: true


#` IndentExportBlock (Boolean) clang-format 20 ¶    !!!!!***NOT USED***  beyond clang-format 19
# If true, clang-format will indent the body of an export { ... } block. This doesn’t affect the formatting of anything else related to exported declarations.
# 
# true:                     false:
# export {          vs.     export {
#   void foo();             void foo();
#   void bar();             void bar();
# }                         }
# ---------------------------------------
#>>>>>
 # IndentExportBlock: true


#` IndentExternBlock (IndentExternBlockStyle) clang-format 11 ¶
# IndentExternBlockStyle is the type of indenting of extern blocks.
# ---------------------------------------

# IEBS_AfterExternBlock (in configuration: AfterExternBlock)  
#     Backwards compatible with AfterExternBlock’s indenting.
# 
# IndentExternBlock: AfterExternBlock
# BraceWrapping.AfterExternBlock: true

  # extern "C"
  # {
  #     void foo();
  # }
# IndentExternBlock: AfterExternBlock
# BraceWrapping.AfterExternBlock: false

  # extern "C" {
  # void foo();
  # }
# ---------------------------------------

# IEBS_NoIndent (in configuration: NoIndent) Does not indent extern blocks.
# 
# extern "C" {
# void foo();
# }
# ---------------------------------------

# IEBS_Indent (in configuration: Indent) Indents extern blocks.
# 
# extern "C" {
#   void foo();
# }
# ---------------------------------------
#>>>>>
 # !_NOTE_! IndentExternBlock: Indent is key to getting the ACFS style (Allman and GNU both set to AfterExternBlock)
IndentExternBlock: Indent


#` IndentGotoLabels (Boolean) clang-format 10 ¶
# Indent goto labels.
# 
# When false, goto labels are flushed left.
# 
# true:                                  false:
# int f() {                      vs.     int f() {
#   if (foo()) {                           if (foo()) {
#   label1:                              label1:
#     bar();                                 bar();
#   }                                      }
# label2:                                label2:
#   return 1;                              return 1;
# }                                      }
# ---------------------------------------
#>>>>>
IndentGotoLabels: true


#` IndentPPDirectives (PPDirectiveIndentStyle) clang-format 6 ¶
# The preprocessor directive indenting style to use.
# ---------------------------------------

# PPDIS_None (in configuration: None) Does not indent any directives.
# 
# #if FOO
# #if BAR
# #include <foo>
# #endif
# #endif
# ---------------------------------------

# PPDIS_AfterHash (in configuration: AfterHash) Indents directives after the hash.
# 
# #if FOO
# #  if BAR
# #    include <foo>
# #  endif
# #endif
# ---------------------------------------

# PPDIS_BeforeHash (in configuration: BeforeHash) Indents directives before the hash.
# 
# #if FOO
#   #if BAR
#     #include <foo>
#   #endif
# #endif
# ---------------------------------------
#>>>>>
 # !_NOTE_! IndentPPDirectives: BeforeHash is key to getting the ACFS style (Allman and GNU both set to None)
IndentPPDirectives: BeforeHash


#` IndentRequiresClause (Boolean) clang-format 15 ¶
# Indent the requires clause in a template. This only applies when RequiresClausePosition is OwnLine, OwnLineWithBrace, or WithFollowing.
# 
# In clang-format 12, 13 and 14 it was named IndentRequires.
# 
# true:
# template <typename It>
#   requires Iterator<It>
# void sort(It begin, It end) {
#   //....
# }
# 
# false:
# template <typename It>
# requires Iterator<It>
# void sort(It begin, It end) {
#   //....
# }
# ---------------------------------------
#>>>>>
IndentRequiresClause: true


#` IndentWidth (Unsigned) clang-format 3.7 ¶#    !!!!!$$$---SPECIFIED AT THE TOP OF THIS FILE---$$$
# The number of columns to use for indentation.
# 
# IndentWidth: 3
# 
# void f() {
#    someFunction();
#    if (true, false) {
#       f();
#    }
# }
# ---------------------------------------
#>>>>>
 # IndentWidth: 2


#` IndentWrappedFunctionNames (Boolean) clang-format 3.7 ¶
# Indent if a function definition or declaration is wrapped after the type.
# 
# true:
# LoooooooooooooooooooooooooooooooooooooooongReturnType
#     LoooooooooooooooooooooooooooooooongFunctionDeclaration();
# 
# false:
# LoooooooooooooooooooooooooooooooooooooooongReturnType
# LoooooooooooooooooooooooooooooooongFunctionDeclaration();
# ---------------------------------------
#>>>>>
IndentWrappedFunctionNames: false


#` InsertBraces (Boolean) clang-format 15 ¶
# Insert braces after control statements (if, else, for, do, and while) in C++ unless the control statements are inside macro definitions or the braces would enclose preprocessor directives.
# 
# Warning
# Setting this option to true could lead to incorrect code formatting due to clang-format’s lack of complete semantic information. As such, extra care should be taken to review code changes made by this option.
# 
# false:                                    true:
# 
# if (isa<FunctionDecl>(D))        vs.      if (isa<FunctionDecl>(D)) {
#   handleFunctionDecl(D);                    handleFunctionDecl(D);
# else if (isa<VarDecl>(D))                 } else if (isa<VarDecl>(D)) {
#   handleVarDecl(D);                         handleVarDecl(D);
# else                                      } else {
#   return;                                   return;
#                                           }
# 
# while (i--)                      vs.      while (i--) {
#   for (auto *A : D.attrs())                 for (auto *A : D.attrs()) {
#     handleAttr(A);                            handleAttr(A);
#                                             }
#                                           }
# 
# do                               vs.      do {
#   --i;                                      --i;
# while (i);                                } while (i);
# ---------------------------------------
#>>>>>
 # !_NOTE_! InsertBraces: true is key to getting the ACFS style (Allman and GNU both set to false)
InsertBraces: true


#` InsertNewlineAtEOF (Boolean) clang-format 16 ¶
# Insert a newline at end of file if missing.
# ---------------------------------------
#>>>>>
InsertNewlineAtEOF: true


#` InsertTrailingCommas (TrailingCommaStyle) clang-format 11 ¶    !!!!!***NOT USED***  For JavaScript only
# If set to TCS_Wrapped will insert trailing commas in container literals (arrays and objects) that wrap across multiple lines. It is currently only available for JavaScript and disabled by default TCS_None. InsertTrailingCommas cannot be used together with BinPackArguments as inserting the comma disables bin-packing.
# 
# TSC_Wrapped:
# const someArray = [
# aaaaaaaaaaaaaaaaaaaaaaaaaa,
# aaaaaaaaaaaaaaaaaaaaaaaaaa,
# aaaaaaaaaaaaaaaaaaaaaaaaaa,
# //                        ^ inserted
# ]
# ---------------------------------------

# TCS_None (in configuration: None) Do not insert trailing commas.
# ---------------------------------------
 
# TCS_Wrapped (in configuration: Wrapped) Insert trailing commas in container literals that were wrapped over multiple lines. Note that this is conceptually incompatible with bin-packing, because the trailing comma is used as an indicator that a container should be formatted one-per-line (i.e. not bin-packed). So inserting a trailing comma counteracts bin-packing.
# ---------------------------------------
#>>>>>
 # InsertTrailingCommas: 


#` IntegerLiteralSeparator (IntegerLiteralSeparatorStyle) clang-format 16 ¶
# Format integer literal separators (' for C++ and _ for C#, Java, and JavaScript).
# 
# Nested configuration flags:
# 
# Separator format of integer literals of different bases.
# 
# If negative, remove separators. If 0, leave the literal as is. If positive, insert separators between digits starting from the rightmost digit.
# 
# For example, the config below will leave separators in binary literals alone, insert separators in decimal literals to separate the digits into groups of 3, and remove separators in hexadecimal literals.
# 
# IntegerLiteralSeparator:
#   Binary: 0
#   Decimal: 3
#   Hex: -1
# You can also specify a minimum number of digits (BinaryMinDigits, DecimalMinDigits, and HexMinDigits) the integer literal must have in order for the separators to be inserted.
# ---------------------------------------
 
# int8_t Binary Format separators in binary literals.
# 
# /* -1: */ b = 0b100111101101;
# /*  0: */ b = 0b10011'11'0110'1;
# /*  3: */ b = 0b100'111'101'101;
# /*  4: */ b = 0b1001'1110'1101;
# ---------------------------------------

# int8_t BinaryMinDigits Format separators in binary literals with a minimum number of digits.
# 
# // Binary: 3
# // BinaryMinDigits: 7
# b1 = 0b101101;
# b2 = 0b1'101'101;
# ---------------------------------------

# int8_t Decimal Format separators in decimal literals.
# 
# /* -1: */ d = 18446744073709550592ull;
# /*  0: */ d = 184467'440737'0'95505'92ull;
# /*  3: */ d = 18'446'744'073'709'550'592ull;
# ---------------------------------------

# int8_t DecimalMinDigits Format separators in decimal literals with a minimum number of digits.
# 
# // Decimal: 3
# // DecimalMinDigits: 5
# d1 = 2023;
# d2 = 10'000;
# ---------------------------------------

# int8_t Hex Format separators in hexadecimal literals.
# 
# /* -1: */ h = 0xDEADBEEFDEADBEEFuz;
# /*  0: */ h = 0xDEAD'BEEF'DE'AD'BEE'Fuz;
# /*  2: */ h = 0xDE'AD'BE'EF'DE'AD'BE'EFuz;
# ---------------------------------------

# int8_t HexMinDigits Format separators in hexadecimal literals with a minimum number of digits.
# 
# // Hex: 2
# // HexMinDigits: 6
# h1 = 0xABCDE;
# h2 = 0xAB'CD'EF;
# ---------------------------------------
#>>>>>
 # !_NOTE_! IntegerLiteralSeparator options are not part of the ACFS style but they can make reading numeric literals easier.
IntegerLiteralSeparator: 
  Binary:  0
  Decimal: 0
  Hex:     0


#` JavaImportGroups (List of Strings) clang-format 8 ¶    !!!!!***NOT USED***  For Java only
# A vector of prefixes ordered by the desired groups for Java imports.
# 
# One group’s prefix can be a subset of another - the longest prefix is always matched. Within a group, the imports are ordered lexicographically. Static imports are grouped separately and follow the same group rules. By default, static imports are placed before non-static imports, but this behavior is changed by another option, SortJavaStaticImport.
# 
# In the .clang-format configuration file, this can be configured like in the following yaml example. This will result in imports being formatted as in the Java example below.
# 
# JavaImportGroups: [com.example, com, org]
# import static com.example.function1;
# 
# import static com.test.function2;
# 
# import static org.example.function3;
# 
# import com.example.ClassA;
# import com.example.Test;
# import com.example.a.ClassB;
# 
# import com.test.ClassC;
# 
# import org.example.ClassD;
# ---------------------------------------
#>>>>>
 # JavaImportGroups: 


#` JavaScriptQuotes (JavaScriptQuoteStyle) clang-format 3.9 ¶    !!!!!***NOT USED***  For JavaScript only
# The JavaScriptQuoteStyle to use for JavaScript strings.
# ---------------------------------------

# JSQS_Leave (in configuration: Leave) Leave string quotes as they are.
# 
# string1 = "foo";
# string2 = 'bar';
# ---------------------------------------

# JSQS_Single (in configuration: Single) Always use single quotes.
# 
# string1 = 'foo';
# string2 = 'bar';
# ---------------------------------------

# JSQS_Double (in configuration: Double) Always use double quotes.
# 
# string1 = "foo";
# string2 = "bar";
# ---------------------------------------
#>>>>>
 # JavaScriptQuotes:


#` JavaScriptWrapImports (Boolean) clang-format 3.9 ¶    !!!!!***NOT USED*** For JavaScript only
# Whether to wrap JavaScript import/export statements.
# 
# true:
# import {
#     VeryLongImportsAreAnnoying,
#     VeryLongImportsAreAnnoying,
#     VeryLongImportsAreAnnoying,
# } from "some/module.js"
# 
# false:
# import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from "some/module.js"
# ---------------------------------------
#>>>>>
 # JavaScriptWrapImports:


#` KeepEmptyLines (KeepEmptyLinesStyle) clang-format 19 ¶
# Which empty lines are kept. See MaxEmptyLinesToKeep for how many consecutive empty lines are kept.
# 
# Nested configuration flags:
# 
# Options regarding which empty lines are kept.
# 
# For example, the config below will remove empty lines at start of the file, end of the file, and start of blocks.
# 
# KeepEmptyLines:
#   AtEndOfFile: false
#   AtStartOfBlock: false
#   AtStartOfFile: false
# ---------------------------------------

# bool AtEndOfFile Keep empty lines at end of file.
# ---------------------------------------
 
# bool AtStartOfBlock Keep empty lines at start of a block.
# 
# true:                                  false:
# if (foo) {                     vs.     if (foo) {
#                                          bar();
#   bar();                               }
# }
# ---------------------------------------

# bool AtStartOfFile Keep empty lines at start of file.
# ---------------------------------------
#>>>>>
KeepEmptyLines: 
  AtEndOfFile: true
  AtStartOfBlock: true
  AtStartOfFile: true


#` KeepEmptyLinesAtEOF (Boolean) clang-format 17 ¶    !!!!!***NOT USED***  deprecated - See AtEndOfFile of KeepEmptyLines.
# This option is deprecated. See AtEndOfFile of KeepEmptyLines.
# ---------------------------------------
#>>>>>
 # KeepEmptyLinesAtEOF: 


#` KeepEmptyLinesAtTheStartOfBlocks (Boolean) clang-format 3.7 ¶    !!!!!***NOT USED***  deprecated - See AtStartOfBlock of KeepEmptyLines.
# This option is deprecated. See AtStartOfBlock of KeepEmptyLines.
# ---------------------------------------
#>>>>>
 # KeepEmptyLinesAtTheStartOfBlocks: 


#` KeepFormFeed (Boolean) clang-format 20 ¶    !!!!!***NOT USED***  beyond clang-format 19
# Keep the form feed character if it’s immediately preceded and followed by a newline. Multiple form feeds and newlines within a whitespace range are replaced with a single newline and form feed followed by the remaining newlines.
# ---------------------------------------
#>>>>>
 # KeepFormFeed: 


#` LambdaBodyIndentation (LambdaBodyIndentationKind) clang-format 13 ¶
# The indentation style of lambda bodies. Signature (the default) causes the lambda body to be indented one additional level relative to the indentation level of the signature. OuterScope forces the lambda body to be indented one additional level relative to the parent scope containing the lambda signature.
# ---------------------------------------

# LBI_Signature (in configuration: Signature) Align lambda body relative to the lambda signature. This is the default.
# 
# someMethod(
#     [](SomeReallyLongLambdaSignatureArgument foo) {
#       return;
#     });
# ---------------------------------------

# LBI_OuterScope (in configuration: OuterScope) For statements within block scope, align lambda body relative to the indentation level of the outer scope the lambda signature resides in.
# 
# someMethod(
#     [](SomeReallyLongLambdaSignatureArgument foo) {
#   return;
# });
# 
# someMethod(someOtherMethod(
#     [](SomeReallyLongLambdaSignatureArgument foo) {
#   return;
# }));
# ---------------------------------------
#>>>>>
LambdaBodyIndentation: Signature


#` Language (LanguageKind) clang-format 3.5 ¶    !!!!!$$$---SPECIFIED AT THE TOP OF THIS FILE---$$$
# The language that this format style targets.
# 
# Note:
# You can also specify the language (Cpp or ObjC) for .h files by adding a // clang-format Language: line before the first non-comment (and non-empty) line, e.g. // clang-format Language: Cpp.
# ---------------------------------------

# LK_None (in configuration: None) Do not use.
# LK_Cpp (in configuration: Cpp) Should be used for C, C++.
# LK_CSharp (in configuration: CSharp) Should be used for C#.
# LK_Java (in configuration: Java) Should be used for Java.
# LK_JavaScript (in configuration: JavaScript) Should be used for JavaScript.
# LK_Json (in configuration: Json) Should be used for JSON.
# LK_ObjC (in configuration: ObjC) Should be used for Objective-C, Objective-C++.
# LK_Proto (in configuration: Proto) Should be used for Protocol Buffers (https://developers.google.com/protocol-buffers/).
# LK_TableGen (in configuration: TableGen) Should be used for TableGen code.
# LK_TextProto (in configuration: TextProto) Should be used for Protocol Buffer messages in text format (https://developers.google.com/protocol-buffers/).
# LK_Verilog (in configuration: Verilog) Should be used for Verilog and SystemVerilog. https://standards.ieee.org/ieee/1800/6700/ https://sci-hub.st/10.1109/IEEESTD.2018.8299595
# ---------------------------------------
#>>>>>
 # Language: 


#` LineEnding (LineEndingStyle) clang-format 16 ¶    !!!!!***NOT USED***  There is no default value
# Line ending style (\n or \r\n) to use.
# ---------------------------------------

# LE_LF (in configuration: LF) Use \n.
# LE_CRLF (in configuration: CRLF) Use \r\n.
# LE_DeriveLF (in configuration: DeriveLF) Use \n unless the input has more lines ending in \r\n.
# LE_DeriveCRLF (in configuration: DeriveCRLF) Use \r\n unless the input has more lines ending in \n.
# ---------------------------------------
#>>>>>
 # LineEnding: 


#` MacroBlockBegin (String) clang-format 3.7 ¶    !!!!!***NOT USED***  (String)
# A regular expression matching macros that start a block.
# 
# # With:
# MacroBlockBegin: "^NS_MAP_BEGIN|\
# NS_TABLE_HEAD$"
# MacroBlockEnd: "^\
# NS_MAP_END|\
# NS_TABLE_.*_END$"
# 
# NS_MAP_BEGIN
#   foo();
# NS_MAP_END
# 
# NS_TABLE_HEAD
#   bar();
# NS_TABLE_FOO_END
# 
# # Without:
# NS_MAP_BEGIN
# foo();
# NS_MAP_END
# 
# NS_TABLE_HEAD
# bar();
# NS_TABLE_FOO_END
# ---------------------------------------
#>>>>>
 # MacroBlockBegin: 


#` MacroBlockEnd (String) clang-format 3.7 ¶    !!!!!***NOT USED***  (String)
# A regular expression matching macros that end a block.
# ---------------------------------------
#>>>>>
 # MacroBlockEnd: 


#` Macros (List of Strings) clang-format 17 ¶    !!!!!***NOT USED***  (List of Strings)
# A list of macros of the form <definition>=<expansion> .
# 
# Code will be parsed with macros expanded, in order to determine how to interpret and format the macro arguments.
# 
# For example, the code:
# 
# A(a*b);
# will usually be interpreted as a call to a function A, and the multiplication expression will be formatted as a * b.
# 
# If we specify the macro definition:
# 
# Macros:
# - A(x)=x
# the code will now be parsed as a declaration of the variable b of type a*, and formatted as a* b (depending on pointer-binding rules).
# ---------------------------------------
 
# Features and restrictions:
# Both function-like macros and object-like macros are supported.
# Macro arguments must be used exactly once in the expansion.
# No recursive expansion; macros referencing other macros will be ignored.
# Overloading by arity is supported: for example, given the macro definitions A=x, A()=y, A(a)=a
# 
# A; -> x;
# A(); -> y;
# A(z); -> z;
# A(a, b); // will not be expanded.
# ---------------------------------------
#>>>>>
 # Macros: 


#` MainIncludeChar (MainIncludeCharDiscriminator) clang-format 19 ¶    !!!!!***NOT USED***  Controls how to guess whether a #include is the “main” include
# When guessing whether a #include is the “main” include, only the include directives that use the specified character are considered.
# ---------------------------------------

# MICD_Quote (in configuration: Quote) Main include uses quotes: #include "foo.hpp" (the default).
# MICD_AngleBracket (in configuration: AngleBracket) Main include uses angle brackets: #include <foo.hpp>.
# MICD_Any (in configuration: Any) Main include uses either quotes or angle brackets.
# ---------------------------------------
#>>>>>
 # MainIncludeChar: 


#` MaxEmptyLinesToKeep (Unsigned) clang-format 3.7 ¶    !!!!!***NOT USED***  No effect when KeepEmptyLines has sub-options set to false
# The maximum number of consecutive empty lines to keep.
# 
# MaxEmptyLinesToKeep: 1         vs.     MaxEmptyLinesToKeep: 0
# int f() {                              int f() {
#   int = 1;                                 int i = 1;
#                                            i = foo();
#   i = foo();                               return i;
#                                        }
#   return i;
# }
# ---------------------------------------
#>>>>>
 # !_NOTE_!  MaxEmptyLinesToKeep should only have an effect when KeepEmptyLines has sub-options set to false.
 # MaxEmptyLinesToKeep:


#` NamespaceIndentation (NamespaceIndentationKind) clang-format 3.7 ¶
# The indentation used for namespaces.
# 
# Possible values:
# 
# NI_None (in configuration: None) Don’t indent in namespaces.
# 
# namespace out {
# int i;
# namespace in {
# int i;
# }
# }
# NI_Inner (in configuration: Inner) Indent only in inner namespaces (nested in other namespaces).
# 
# namespace out {
# int i;
# namespace in {
#   int i;
# }
# }
# NI_All (in configuration: All) Indent in all namespaces.
# 
# namespace out {
#   int i;
#   namespace in {
#     int i;
#   }
# }
# ---------------------------------------
#>>>>>
NamespaceIndentation: All


#` NamespaceMacros (List of Strings) clang-format 9 ¶    !!!!!***NOT USED***  (List of Strings)
# A vector of macros which are used to open namespace blocks.
# 
# These are expected to be macros of the form:
# 
# NAMESPACE(<namespace-name>, ...) {
#   <namespace-content>
# }
# For example: TESTSUITE
# ---------------------------------------
#>>>>>
 # NamespaceMacros: 


#` ObjCBinPackProtocolList (BinPackStyle) clang-format 7 ¶    !!!!!***NOT USED***  For Objective-C only
# Controls bin-packing Objective-C protocol conformance list items into as few lines as possible when they go over ColumnLimit.
# 
# If Auto (the default), delegates to the value in BinPackParameters. If that is BinPack, bin-packs Objective-C protocol conformance list items into as few lines as possible whenever they go over ColumnLimit.
# 
# If Always, always bin-packs Objective-C protocol conformance list items into as few lines as possible whenever they go over ColumnLimit.
# 
# If Never, lays out Objective-C protocol conformance list items onto individual lines whenever they go over ColumnLimit.
# 
# Always (or Auto, if BinPackParameters==BinPack):
# @interface ccccccccccccc () <
#     ccccccccccccc, ccccccccccccc,
#     ccccccccccccc, ccccccccccccc> {
# }
# 
# Never (or Auto, if BinPackParameters!=BinPack):
# @interface ddddddddddddd () <
#     ddddddddddddd,
#     ddddddddddddd,
#     ddddddddddddd,
#     ddddddddddddd> {
# }
# ---------------------------------------

# BPS_Auto (in configuration: Auto) Automatically determine parameter bin-packing behavior.
# BPS_Always (in configuration: Always) Always bin-pack parameters.
# BPS_Never (in configuration: Never) Never bin-pack parameters.
# ---------------------------------------
#>>>>>
 # ObjCBinPackProtocolList: 


#` ObjCBlockIndentWidth (Unsigned) clang-format 3.7 ¶    !!!!!***NOT USED***  For Objective-C only
# The number of characters to use for indentation of ObjC blocks.
# 
# ObjCBlockIndentWidth: 4
# 
# [operation setCompletionBlock:^{
#     [self onOperationDone];
# }];
# ---------------------------------------
#>>>>>
 # ObjCBlockIndentWidth: 


#` ObjCBreakBeforeNestedBlockParam (Boolean) clang-format 11 ¶   !!!!!***NOT USED***  For Objective-C only
# Break parameters list into lines when there is nested block parameters in a function call.
# 
# false:
#  - (void)_aMethod
#  {
#      [self.test1 t:self w:self callback:^(typeof(self) self, NSNumber
#      *u, NSNumber *v) {
#          u = c;
#      }]
#  }
#  true:
#  - (void)_aMethod
#  {
#     [self.test1 t:self
#                  w:self
#         callback:^(typeof(self) self, NSNumber *u, NSNumber *v) {
#              u = c;
#          }]
#  }
# ---------------------------------------
#>>>>>
 # ObjCBreakBeforeNestedBlockParam: true


#` ObjCPropertyAttributeOrder (List of Strings) clang-format 18 ¶    !!!!!***NOT USED*** For Objective-C only
# The order in which ObjC property attributes should appear.
# 
# Attributes in code will be sorted in the order specified. Any attributes encountered that are not mentioned in this array will be sorted last, in stable order. Comments between attributes will leave the attributes untouched.
# 
# Warning
# Using this option could lead to incorrect code formatting due to clang-format’s lack of complete semantic information. As such, extra care should be taken to review code changes made by this option.
# 
# ObjCPropertyAttributeOrder: [
#     class, direct,
#     atomic, nonatomic,
#     assign, retain, strong, copy, weak, unsafe_unretained,
#     readonly, readwrite, getter, setter,
#     nullable, nonnull, null_resettable, null_unspecified
# ]
# ---------------------------------------
#>>>>>
 # ObjCPropertyAttributeOrder: 


#` ObjCSpaceAfterProperty (Boolean) clang-format 3.7 ¶    !!!!!***NOT USED*** For Objective-C only
# Add a space after @property in Objective-C, i.e. use @property (readonly) instead of @property(readonly).
# ---------------------------------------
#>>>>>
 # ObjCSpaceAfterProperty: 


#` ObjCSpaceBeforeProtocolList (Boolean) clang-format 3.7 ¶    !!!!!***NOT USED*** For Objective-C only
# Add a space in front of an Objective-C protocol list, i.e. use Foo <Protocol> instead of Foo<Protocol>.
# ---------------------------------------
#>>>>>
 # ObjCSpaceBeforeProtocolList: 


#` PPIndentWidth (Integer) clang-format 13 ¶
# The number of columns to use for indentation of preprocessor statements. When set to -1 (default) IndentWidth is used also for preprocessor statements.
# 
# PPIndentWidth: 1
# 
# #ifdef __linux__
# # define FOO
# #else
# # define BAR
# #endif
# ---------------------------------------
#>>>>>
PPIndentWidth: -1


#` PackConstructorInitializers (PackConstructorInitializersStyle) clang-format 14 ¶
# The pack constructor initializers style to use.
# ---------------------------------------

# PCIS_Never (in configuration: Never) Always put each constructor initializer on its own line.
# 
# Constructor()
#     : a(),
#       b()
# ---------------------------------------

# PCIS_BinPack (in configuration: BinPack) Bin-pack constructor initializers.
# 
# Constructor()
#     : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(),
#       cccccccccccccccccccc()
# ---------------------------------------

# PCIS_CurrentLine (in configuration: CurrentLine) Put all constructor initializers on the current line if they fit. Otherwise, put each one on its own line.
# 
# Constructor() : a(), b()
# 
# Constructor()
#     : aaaaaaaaaaaaaaaaaaaa(),
#       bbbbbbbbbbbbbbbbbbbb(),
#       ddddddddddddd()
# ---------------------------------------

# PCIS_NextLine (in configuration: NextLine) Same as PCIS_CurrentLine except that if all constructor initializers do not fit on the current line, try to fit them on the next line.
# 
# Constructor() : a(), b()
# 
# Constructor()
#     : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd()
# 
# Constructor()
#     : aaaaaaaaaaaaaaaaaaaa(),
#       bbbbbbbbbbbbbbbbbbbb(),
#       cccccccccccccccccccc()
# ---------------------------------------

# PCIS_NextLineOnly (in configuration: NextLineOnly) Put all constructor initializers on the next line if they fit. Otherwise, put each one on its own line.
# 
# Constructor()
#     : a(), b()
# 
# Constructor()
#     : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd()
# 
# Constructor()
#     : aaaaaaaaaaaaaaaaaaaa(),
#       bbbbbbbbbbbbbbbbbbbb(),
#       cccccccccccccccccccc()
# ---------------------------------------
#>>>>>
PackConstructorInitializers: CurrentLine


# For an example of clang-format Penalties see:  https://github.com/git/git/blob/master/.clang-format
 # !_NOTE_! Clang-format uses penalties to decide where to break a line when the ColumnLimit value will be exceeded.
#           Therefore, penalties are not needed if the ColumnLimit is set to 0 (which means unlimited column width)

#` PenaltyBreakAssignment (Unsigned) clang-format 5 ¶    !!!!!***NOT USED***  ColumnLimit: 0 so penalty not used
# The penalty for breaking around an assignment operator.
# ---------------------------------------
#>>>>>
 # PenaltyBreakAssignment: 5


#` PenaltyBreakBeforeFirstCallParameter (Unsigned) clang-format 3.7 ¶    !!!!!***NOT USED***  ColumnLimit: 0 so penalty not used
# The penalty for breaking a function call after call(.
# ---------------------------------------
#>>>>>
 # PenaltyBreakBeforeFirstCallParameter: 5


#` PenaltyBreakBeforeMemberAccess (Unsigned) clang-format 20 ¶    !!!!!***NOT USED***  beyond clang-format 19       ColumnLimit: 0 so penalty not used
# The penalty for breaking before a member access operator (., ->).
# ---------------------------------------
#>>>>>
 # PenaltyBreakBeforeMemberAccess: 


#` PenaltyBreakComment (Unsigned) clang-format 3.7 ¶    !!!!!***NOT USED***  ColumnLimit: 0 so penalty not used
# The penalty for each line break introduced inside a comment.
# ---------------------------------------
#>>>>>
 # PenaltyBreakComment: 5


#` PenaltyBreakFirstLessLess (Unsigned) clang-format 3.7 ¶    !!!!!***NOT USED***  ColumnLimit: 0 so penalty not used
# The penalty for breaking before the first <<.
# ---------------------------------------
#>>>>>
 # PenaltyBreakFirstLessLess: 0


#` PenaltyBreakOpenParenthesis (Unsigned) clang-format 14 ¶    !!!!!***NOT USED***  ColumnLimit: 0 so penalty not used
# The penalty for breaking after (.
# ---------------------------------------
#>>>>>
 # PenaltyBreakOpenParenthesis: 300


#` PenaltyBreakScopeResolution (Unsigned) clang-format 18 ¶    !!!!!***NOT USED***  ColumnLimit: 0 so penalty not used
# The penalty for breaking after ::.
# ---------------------------------------
#>>>>>
 # PenaltyBreakScopeResolution: 


#` PenaltyBreakString (Unsigned) clang-format 3.7 ¶    !!!!!***NOT USED***  ColumnLimit: 0 so penalty not used
# The penalty for each line break introduced inside a string literal.
# ---------------------------------------
#>>>>>
 # PenaltyBreakString: 5


#` PenaltyBreakTemplateDeclaration (Unsigned) clang-format 7 ¶    !!!!!***NOT USED***  ColumnLimit: 0 so penalty not used
# The penalty for breaking after template declaration.
# ---------------------------------------
#>>>>>
 # PenaltyBreakTemplateDeclaration: 


#` PenaltyExcessCharacter (Unsigned) clang-format 3.7 ¶    !!!!!***NOT USED***  ColumnLimit: 0 so penalty not used
# The penalty for each character outside of the column limit.
# ---------------------------------------
#>>>>>
 # PenaltyExcessCharacter: 10


#` PenaltyIndentedWhitespace (Unsigned) clang-format 12 ¶    !!!!!***NOT USED***  ColumnLimit: 0 so penalty not used
# Penalty for each character of whitespace indentation (counted relative to leading non-whitespace column).
# ---------------------------------------
#>>>>>
 # PenaltyIndentedWhitespace: 


#` PenaltyReturnTypeOnItsOwnLine (Unsigned) clang-format 3.7 ¶    !!!!!***NOT USED***  ColumnLimit: 0 so penalty not used
# Penalty for putting the return type of a function onto its own line.
# ---------------------------------------
#>>>>>
 # PenaltyReturnTypeOnItsOwnLine: 300


#` PointerAlignment (PointerAlignmentStyle) clang-format 3.7 ¶    !!!!!$$$---SPECIFIED AT THE TOP OF THIS FILE---$$$
# Pointer and reference alignment style.
# ---------------------------------------

# PAS_Left (in configuration: Left) Align pointer to the left.
# 
# int* a;
# ---------------------------------------

# PAS_Right (in configuration: Right) Align pointer to the right.
# 
# int *a;
# ---------------------------------------

# PAS_Middle (in configuration: Middle) Align pointer in the middle.
# 
# int * a;
# ---------------------------------------
#>>>>>
 # PointerAlignment: 


#` QualifierAlignment (QualifierAlignmentStyle) clang-format 14 ¶
# Different ways to arrange specifiers and qualifiers (e.g. const/volatile).
# 
# Warning
# 
# Setting QualifierAlignment to something other than Leave, COULD lead to incorrect code formatting due to incorrect decisions made due to clang-formats lack of complete semantic information. As such extra care should be taken to review code changes made by the use of this option.
# ---------------------------------------
 
# QAS_Leave (in configuration: Leave) Don’t change specifiers/qualifiers to either Left or Right alignment (default).
# 
# int const a;
# const int *a;
# ---------------------------------------

# QAS_Left (in configuration: Left) Change specifiers/qualifiers to be left-aligned.
# 
# const int a;
# const int *a;
# ---------------------------------------

# QAS_Right (in configuration: Right) Change specifiers/qualifiers to be right-aligned.
# 
# int const a;
# int const *a;
# ---------------------------------------

# QAS_Custom (in configuration: Custom) Change specifiers/qualifiers to be aligned based on QualifierOrder. With:
# 
# QualifierOrder: [inline, static, type, const]
# int const a;
# int const *a;
# ---------------------------------------
#>>>>>
QualifierAlignment: Leave


#` QualifierOrder (List of Strings) clang-format 14 ¶    !!!!!***NOT USED***  (List of Strings)
# The order in which the qualifiers appear. The order is an array that can contain any of the following:
# 
# const
# inline
# static
# friend
# constexpr
# volatile
# restrict
# type
#
# Note: 
# It must contain type.
# 
# Items to the left of type will be placed to the left of the type and aligned in the order supplied. Items to the right of type will be placed to the right of the type and aligned in the order supplied.
# 
# QualifierOrder: [inline, static, type, const, volatile]
# ---------------------------------------
#>>>>>
 # QualifierOrder: 


#` RawStringFormats (List of RawStringFormats) clang-format 6 ¶    !!!!!***NOT USED***  (List of RawStringFormats)
# Defines hints for detecting supported languages code blocks in raw strings.
# 
# A raw string with a matching delimiter or a matching enclosing function name will be reformatted assuming the specified language based on the style for that language defined in the .clang-format file. If no style has been defined in the .clang-format file for the specific language, a predefined style given by BasedOnStyle is used. If BasedOnStyle is not found, the formatting is based on LLVM style. A matching delimiter takes precedence over a matching enclosing function name for determining the language of the raw string contents.
# 
# If a canonical delimiter is specified, occurrences of other delimiters for the same language will be updated to the canonical if possible.
# 
# There should be at most one specification per language and each delimiter and enclosing function should not occur in multiple specifications.
# 
# To configure this in the .clang-format file, use:
# 
# RawStringFormats:
#   - Language: TextProto
#       Delimiters:
#         - pb
#         - proto
#       EnclosingFunctions:
#         - PARSE_TEXT_PROTO
#       BasedOnStyle: google
#   - Language: Cpp
#       Delimiters:
#         - cc
#         - cpp
#       BasedOnStyle: LLVM
#       CanonicalDelimiter: cc
# ---------------------------------------
#>>>>>
 # RawStringFormats: 


#` ReferenceAlignment (ReferenceAlignmentStyle) clang-format 13 ¶    !!!!!***NOT USED***  PointerAlignment is used instead
# Reference alignment style (overrides PointerAlignment for references).
# ---------------------------------------

# RAS_Pointer (in configuration: Pointer) Align reference like PointerAlignment.
# ---------------------------------------
 
# RAS_Left (in configuration: Left) Align reference to the left.
# 
# int& a;
# ---------------------------------------

# RAS_Right (in configuration: Right) Align reference to the right.
# 
# int &a;
# ---------------------------------------

# RAS_Middle (in configuration: Middle) Align reference in the middle.
# 
# int & a;
# ---------------------------------------
#>>>>>
 # ReferenceAlignment: 


# The following is what the Clang 21.0.0git documentation says
#
#` ReflowComments (ReflowCommentsStyle) clang-format 3.8 ¶   !!!!!***NOT USED***  This is actually incorrect.
# Comment reformatting style.
# ---------------------------------------

# RCS_Never (in configuration: Never) Leave comments untouched.
# 
# // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information
# /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */
# /* third veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information
#      * and a misaligned second line */
# ---------------------------------------

# RCS_IndentOnly (in configuration: IndentOnly) Only apply indentation rules, moving comments left or right, without changing formatting inside the comments.
# 
# // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information
# /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */
# /* third veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information
#  * and a misaligned second line */
# ---------------------------------------

# RCS_Always (in configuration: Always) Apply indentation rules and reflow long comments into new lines, trying to obey the ColumnLimit.
# 
# // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of
# // information
# /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of
#  * information */
# /* third veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of
#  * information and a misaligned second line */
# ---------------------------------------
#>>>>>
 # ReflowComments: Never


# BUT this is what it is (per Clang 18.0.0git documentation)
#
#` ReflowComments (Boolean) clang-format 3.8 ¶
# If true, clang-format will attempt to re-flow comments. That is it will touch a comment and reflow long comments into new lines, trying to obey the ColumnLimit.
# 
# false:
# // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information
# /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */
# 
# true:
# // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of
# // information
# /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of
#  * information */
# ---------------------------------------
#>>>>>
ReflowComments: false


#` RemoveBracesLLVM (Boolean) clang-format 14 ¶    !!!!!***NOT USED***  Applies only if using the LLVM coding style
# Remove optional braces of control statements (if, else, for, and while) in C++ according to the LLVM coding style.
# 
# Warning
# 
# This option will be renamed and expanded to support other styles.
# 
# Warning
# 
# Setting this option to true could lead to incorrect code formatting due to clang-format’s lack of complete semantic information. As such, extra care should be taken to review code changes made by this option.
# 
# false:                                     true:
# 
# if (isa<FunctionDecl>(D)) {        vs.     if (isa<FunctionDecl>(D))
#   handleFunctionDecl(D);                     handleFunctionDecl(D);
# } else if (isa<VarDecl>(D)) {              else if (isa<VarDecl>(D))
#   handleVarDecl(D);                          handleVarDecl(D);
# }
# 
# if (isa<VarDecl>(D)) {             vs.     if (isa<VarDecl>(D)) {
#   for (auto *A : D.attrs()) {                for (auto *A : D.attrs())
#     if (shouldProcessAttr(A)) {                if (shouldProcessAttr(A))
#       handleAttr(A);                             handleAttr(A);
#     }                                      }
#   }
# }
# 
# if (isa<FunctionDecl>(D)) {        vs.     if (isa<FunctionDecl>(D))
#   for (auto *A : D.attrs()) {                for (auto *A : D.attrs())
#     handleAttr(A);                             handleAttr(A);
#   }
# }
# 
# if (auto *D = (T)(D)) {            vs.     if (auto *D = (T)(D)) {
#   if (shouldProcess(D)) {                    if (shouldProcess(D))
#     handleVarDecl(D);                          handleVarDecl(D);
#   } else {                                   else
#     markAsIgnored(D);                          markAsIgnored(D);
#   }                                        }
# }
# 
# if (a) {                           vs.     if (a)
#   b();                                       b();
# } else {                                   else if (c)
#   if (c) {                                   d();
#     d();                                   else
#   } else {                                   e();
#     e();
#   }
# }
# ---------------------------------------
#>>>>>
 # RemoveBracesLLVM: 


#` RemoveEmptyLinesInUnwrappedLines (Boolean) clang-format 20 ¶    !!!!!***NOT USED***  beyond clang-format 19
# Remove empty lines within unwrapped lines.
# 
# false:                            true:
# 
# int c                  vs.        int c = a + b;
# 
#     = a + b;
# 
# enum : unsigned        vs.        enum : unsigned {
#                                     AA = 0,
# {                                   BB
#   AA = 0,                         } myEnum;
#   BB
# } myEnum;
# 
# while (                vs.        while (true) {
#                                   }
#     true) {
# }
# ---------------------------------------
#>>>>>
 # RemoveEmptyLinesInUnwrappedLines: 


#` RemoveParentheses (RemoveParenthesesStyle) clang-format 17 ¶
# Remove redundant parentheses.
# 
# Warning
# 
# Setting this option to any value other than Leave could lead to incorrect code formatting due to clang-format’s lack of complete semantic information. As such, extra care should be taken to review code changes made by this option.
# 
# Possible values:
# 
# RPS_Leave (in configuration: Leave) Do not remove parentheses.
# 
# class __declspec((dllimport)) X {};
# co_return (((0)));
# return ((a + b) - ((c + d)));
# ---------------------------------------

# RPS_MultipleParentheses (in configuration: MultipleParentheses) Replace multiple parentheses with single parentheses.
# 
# class __declspec(dllimport) X {};
# co_return (0);
# return ((a + b) - (c + d));
# ---------------------------------------

# RPS_ReturnStatement (in configuration: ReturnStatement) Also remove parentheses enclosing the expression in a return/co_return statement.
# 
# class __declspec(dllimport) X {};
# co_return 0;
# return (a + b) - (c + d);
# ---------------------------------------
#>>>>>
RemoveParentheses: Leave


#` RemoveSemicolon (Boolean) clang-format 16 ¶
# Remove semicolons after the closing braces of functions and constructors/destructors.
# 
# Warning
# 
# Setting this option to true could lead to incorrect code formatting due to clang-format’s lack of complete semantic information. As such, extra care should be taken to review code changes made by this option.
# 
# false:                                     true:
# 
# int max(int a, int b) {                    int max(int a, int b) {
#   return a > b ? a : b;                      return a > b ? a : b;
# };     
# ---------------------------------------
#>>>>>
RemoveSemicolon: false


#` RequiresClausePosition (RequiresClausePositionStyle) clang-format 15 ¶
# The position of the requires clause.
# ---------------------------------------

# RCPS_OwnLine (in configuration: OwnLine) Always put the requires clause on its own line (possibly followed by a semicolon).
# 
# template <typename T>
#   requires C<T>
# struct Foo {...
# 
# template <typename T>
# void bar(T t)
#   requires C<T>;
# 
# template <typename T>
#   requires C<T>
# void bar(T t) {...
# 
# template <typename T>
# void baz(T t)
#   requires C<T>
# {...
# ---------------------------------------

# RCPS_OwnLineWithBrace (in configuration: OwnLineWithBrace) As with OwnLine, except, unless otherwise prohibited, place a following open brace (of a function definition) to follow on the same line.
# 
# void bar(T t)
#   requires C<T> {
#   return;
# }
# 
# void bar(T t)
#   requires C<T> {}
# 
# template <typename T>
#   requires C<T>
# void baz(T t) {
#   ...
# ---------------------------------------

# RCPS_WithPreceding (in configuration: WithPreceding) Try to put the clause together with the preceding part of a declaration. For class templates: stick to the template declaration. For function templates: stick to the template declaration. For function declaration followed by a requires clause: stick to the parameter list.
# 
# template <typename T> requires C<T>
# struct Foo {...
# 
# template <typename T> requires C<T>
# void bar(T t) {...
# 
# template <typename T>
# void baz(T t) requires C<T>
# {...
# ---------------------------------------

# RCPS_WithFollowing (in configuration: WithFollowing) Try to put the requires clause together with the class or function declaration.
# 
# template <typename T>
# requires C<T> struct Foo {...
# 
# template <typename T>
# requires C<T> void bar(T t) {...
# 
# template <typename T>
# void baz(T t)
# requires C<T> {...
# ---------------------------------------

# RCPS_SingleLine (in configuration: SingleLine) Try to put everything in the same line if possible. Otherwise normal line breaking rules take over.
# 
# // Fitting:
# template <typename T> requires C<T> struct Foo {...
# 
# template <typename T> requires C<T> void bar(T t) {...
# 
# template <typename T> void bar(T t) requires C<T> {...
# 
# // Not fitting, one possible example:
# template <typename LongName>
# requires C<LongName>
# struct Foo {...
# 
# template <typename LongName>
# requires C<LongName>
# void bar(LongName ln) {
# 
# template <typename LongName>
# void bar(LongName ln)
#     requires C<LongName> {
# ---------------------------------------
#>>>>>
RequiresClausePosition: OwnLine


#` RequiresExpressionIndentation (RequiresExpressionIndentationKind) clang-format 16 ¶
# The indentation used for requires expression bodies.
# ---------------------------------------

# REI_OuterScope (in configuration: OuterScope) Align requires expression body relative to the indentation level of the outer scope the requires expression resides in. This is the default.
# 
# template <typename T>
# concept C = requires(T t) {
#   ...
# }
# ---------------------------------------

# REI_Keyword (in configuration: Keyword) Align requires expression body relative to the requires keyword.
# 
# template <typename T>
# concept C = requires(T t) {
#               ...
#             }
# ---------------------------------------
#>>>>>
RequiresExpressionIndentation: OuterScope


#` SeparateDefinitionBlocks (SeparateDefinitionStyle) clang-format 14 ¶
# Specifies the use of empty lines to separate definition blocks, including classes, structs, enums, and functions.
# 
# Never                  v.s.     Always
# #include <cstring>              #include <cstring>
# struct Foo {
#   int a, b, c;                  struct Foo {
# };                                int a, b, c;
# namespace Ns {                  };
# class Bar {
# public:                         namespace Ns {
#   struct Foobar {               class Bar {
#     int a;                      public:
#     int b;                        struct Foobar {
#   };                                int a;
# private:                            int b;
#   int t;                          };
#   int method1() {
#     // ...                      private:
#   }                               int t;
#   enum List {
#     ITEM1,                        int method1() {
#     ITEM2                           // ...
#   };                              }
#   template<typename T>
#   int method2(T x) {              enum List {
#     // ...                          ITEM1,
#   }                                 ITEM2
#   int i, j, k;                    };
#   int method3(int par) {
#     // ...                        template<typename T>
#   }                               int method2(T x) {
# };                                  // ...
# class C {};                       }
# }
#                                   int i, j, k;
# 
#                                   int method3(int par) {
#                                     // ...
#                                   }
#                                 };
# 
#                                 class C {};
#                                 }
# ---------------------------------------

# SDS_Leave (in configuration: Leave) Leave definition blocks as they are.
# SDS_Always (in configuration: Always) Insert an empty line between definition blocks.
# SDS_Never (in configuration: Never) Remove any empty line between definition blocks.
# ---------------------------------------
#>>>>>
SeparateDefinitionBlocks: Always


#` ShortNamespaceLines (Unsigned) clang-format 13 ¶    !!!!!***NOT USED***  Should have no effect when FixNamespaceComments: false
# The maximal number of unwrapped lines that a short namespace spans. Defaults to 1.
# 
# This determines the maximum length of short namespaces by counting unwrapped lines (i.e. containing neither opening nor closing namespace brace) and makes FixNamespaceComments omit adding end comments for those.
# 
# ShortNamespaceLines: 1     vs.     ShortNamespaceLines: 0
# namespace a {                      namespace a {
#   int foo;                           int foo;
# }                                  } // namespace a
# 
# ShortNamespaceLines: 1     vs.     ShortNamespaceLines: 0
# namespace b {                      namespace b {
#   int foo;                           int foo;
#   int bar;                           int bar;
# } // namespace b                   } // namespace b
# ---------------------------------------
#>>>>>
  # !_NOTE_! Should have no effect when FixNamespaceComments: false
 # ShortNamespaceLines: 


#` SkipMacroDefinitionBody (Boolean) clang-format 18 ¶
# Do not format macro definition body.
# ---------------------------------------
#>>>>>
SkipMacroDefinitionBody: true


#` SortIncludes (SortIncludesOptions) clang-format 3.8 ¶
# Controls if and how clang-format will sort #includes.
# ---------------------------------------

# SI_Never (in configuration: Never) Includes are never sorted.
# 
# #include "B/A.h"
# #include "A/B.h"
# #include "a/b.h"
# #include "A/b.h"
# #include "B/a.h"
# ---------------------------------------

# SI_CaseSensitive (in configuration: CaseSensitive) Includes are sorted in an ASCIIbetical or case sensitive fashion.
# 
# #include "A/B.h"
# #include "A/b.h"
# #include "B/A.h"
# #include "B/a.h"
# #include "a/b.h"
# ---------------------------------------

# SI_CaseInsensitive (in configuration: CaseInsensitive) Includes are sorted in an alphabetical or case insensitive fashion.  <<<<< CaseInsensitive is the default
# 
# #include "A/B.h"
# #include "A/b.h"
# #include "a/b.h"
# #include "B/A.h"
# #include "B/a.h"
# ---------------------------------------
#>>>>>
 # !_NOTE_! If you do not set SortIncludes then it defaults to SortIncludes: CaseInsensitive
SortIncludes: Never


#` SortJavaStaticImport (SortJavaStaticImportOptions) clang-format 12 ¶    !!!!!***NOT USED***  For Java only
# When sorting Java imports, by default static imports are placed before non-static imports. If JavaStaticImportAfterImport is After, static imports are placed after non-static imports.
# 
# Possible values:
# 
# SJSIO_Before (in configuration: Before) Static imports are placed before non-static imports.
# 
# import static org.example.function1;
# 
# import org.example.ClassA;
# SJSIO_After (in configuration: After) Static imports are placed after non-static imports.
# 
# import org.example.ClassA;
# 
# import static org.example.function1;
# ---------------------------------------
#>>>>>
 # SortJavaStaticImport: 


#` SortUsingDeclarations (SortUsingDeclarationsOptions) clang-format 5 ¶
# Controls if and how clang-format will sort using declarations.
# ---------------------------------------

# SUD_Never (in configuration: Never) Using declarations are never sorted.
# 
# using std::chrono::duration_cast;
# using std::move;
# using boost::regex;
# using boost::regex_constants::icase;
# using std::string;
# ---------------------------------------

# SUD_Lexicographic (in configuration: Lexicographic) Using declarations are sorted in the order defined as follows: Split the strings by :: and discard any initial empty strings. Sort the lists of names lexicographically, and within those groups, names are in case-insensitive lexicographic order.
# 
# using boost::regex;
# using boost::regex_constants::icase;
# using std::chrono::duration_cast;
# using std::move;
# using std::string;
# ---------------------------------------

# SUD_LexicographicNumeric (in configuration: LexicographicNumeric) Using declarations are sorted in the order defined as follows: Split the strings by :: and discard any initial empty strings. The last element of each list is a non-namespace name; all others are namespace names. Sort the lists of names lexicographically, where the sort order of individual names is that all non-namespace names come before all namespace names, and within those groups, names are in case-insensitive lexicographic order.
# 
# using boost::regex;
# using boost::regex_constants::icase;
# using std::move;
# using std::string;
# using std::chrono::duration_cast;
# ---------------------------------------
#>>>>>
SortUsingDeclarations: Never


#` SpaceAfterCStyleCast (Boolean) clang-format 3.5 ¶
# If true, a space is inserted after C style casts.
# 
# true:                                  false:
# (int) i;                       vs.     (int)i;
# ---------------------------------------
#>>>>>
SpaceAfterCStyleCast: false


#` SpaceAfterLogicalNot (Boolean) clang-format 9 ¶
# If true, a space is inserted after the logical not operator (!).
# 
# true:                                  false:
# ! someExpression();            vs.     !someExpression();
# ---------------------------------------
#>>>>>
SpaceAfterLogicalNot: false


#` SpaceAfterTemplateKeyword (Boolean) clang-format 4 ¶
# If true, a space will be inserted after the template keyword.
# 
# true:                                  false:
# template <int> void foo();     vs.     template<int> void foo();
# ---------------------------------------
#>>>>>
SpaceAfterTemplateKeyword: false


#` SpaceAroundPointerQualifiers (SpaceAroundPointerQualifiersStyle) clang-format 12 ¶    !!!!!***NOT USED*** PointerAlignment is used instead
# Defines in which cases to put a space before or after pointer qualifiers
# ---------------------------------------

# SAPQ_Default (in configuration: Default) Don’t ensure spaces around pointer qualifiers and use PointerAlignment instead.
# 
# PointerAlignment: Left                 PointerAlignment: Right
# void* const* x = NULL;         vs.     void *const *x = NULL;
# ---------------------------------------

# SAPQ_Before (in configuration: Before) Ensure that there is a space before pointer qualifiers.
# 
# PointerAlignment: Left                 PointerAlignment: Right
# void* const* x = NULL;         vs.     void * const *x = NULL;
# ---------------------------------------

# SAPQ_After (in configuration: After) Ensure that there is a space after pointer qualifiers.
# 
# PointerAlignment: Left                 PointerAlignment: Right
# void* const * x = NULL;         vs.     void *const *x = NULL;
# ---------------------------------------

# SAPQ_Both (in configuration: Both) Ensure that there is a space both before and after pointer qualifiers.
# 
# PointerAlignment: Left                 PointerAlignment: Right
# void* const * x = NULL;         vs.     void * const *x = NULL;
# ---------------------------------------
#>>>>>
 # SpaceAroundPointerQualifiers: 


#` SpaceBeforeAssignmentOperators (Boolean) clang-format 3.7 ¶
# If false, spaces will be removed before assignment operators.
# 
# true:                                  false:
# int a = 5;                     vs.     int a= 5;
# a += 42;                               a+= 42;
# ---------------------------------------
#>>>>>
SpaceBeforeAssignmentOperators: true


#` SpaceBeforeCaseColon (Boolean) clang-format 12 ¶
# If false, spaces will be removed before case colon.
# 
# true:                                   false
# switch (x) {                    vs.     switch (x) {
#   case 1 : break;                         case 1: break;
# }                                       }
# ---------------------------------------
#>>>>>
SpaceBeforeCaseColon: false


#` SpaceBeforeCpp11BracedList (Boolean) clang-format 7 ¶
# If true, a space will be inserted before a C++11 braced list used to initialize an object (after the preceding identifier or type).
# 
# true:                                  false:
# Foo foo { bar };               vs.     Foo foo{ bar };
# Foo {};                                Foo{};
# vector<int> { 1, 2, 3 };               vector<int>{ 1, 2, 3 };
# new int[3] { 1, 2, 3 };                new int[3]{ 1, 2, 3 };
# ---------------------------------------
#>>>>>
SpaceBeforeCpp11BracedList: true


#` SpaceBeforeCtorInitializerColon (Boolean) clang-format 7 ¶
# If false, spaces will be removed before constructor initializer colon.
# 
# true:                                  false:
# Foo::Foo() : a(a) {}                   Foo::Foo(): a(a) {}
# ---------------------------------------
#>>>>>
SpaceBeforeCtorInitializerColon: true


#` SpaceBeforeInheritanceColon (Boolean) clang-format 7 ¶
# If false, spaces will be removed before inheritance colon.
# 
# true:                                  false:
# class Foo : Bar {}             vs.     class Foo: Bar {}
# ---------------------------------------
#>>>>>
SpaceBeforeInheritanceColon: true


#` SpaceBeforeJsonColon (Boolean) clang-format 17 ¶
# If true, a space will be added before a JSON colon. For other languages, e.g. JavaScript, use SpacesInContainerLiterals instead.
# 
# true:                                  false:
# {                                      {
#   "key" : "value"              vs.       "key": "value"
# }                                      }
# ---------------------------------------
#>>>>>
SpaceBeforeJsonColon: true

#` SpaceBeforeParens (SpaceBeforeParensStyle) clang-format 3.5 ¶
# Defines in which cases to put a space before opening parentheses.
# ---------------------------------------

# SBPO_Never (in configuration: Never) This is deprecated and replaced by Custom below, with all SpaceBeforeParensOptions but AfterPlacementOperator set to false.
# 
# SBPO_ControlStatements (in configuration: ControlStatements) Put a space before opening parentheses only after control statement keywords (for/if/while...).
# 
# void f() {
#   if (true) {
#     f();
#   }
# }
# ---------------------------------------

# SBPO_ControlStatementsExceptControlMacros (in configuration: ControlStatementsExceptControlMacros) Same as SBPO_ControlStatements except this option doesn’t apply to ForEach and If macros. This is useful in projects where ForEach/If macros are treated as function calls instead of control statements. SBPO_ControlStatementsExceptForEachMacros remains an alias for backward compatibility.
# 
# void f() {
#   Q_FOREACH(...) {
#     f();
#   }
# }
# ---------------------------------------

# SBPO_NonEmptyParentheses (in configuration: NonEmptyParentheses) Put a space before opening parentheses only if the parentheses are not empty.
# 
# void() {
#   if (true) {
#     f();
#     g (x, y, z);
#   }
# }
# ---------------------------------------

# SBPO_Always (in configuration: Always) Always put a space before opening parentheses, except when it’s prohibited by the syntax rules (in function-like macro definitions) or when determined by other style rules (after unary operators, opening parentheses, etc.)
# 
# void f () {
#   if (true) {
#     f ();
#   }
# }
# ---------------------------------------

# SBPO_Custom (in configuration: Custom) Configure each individual space before parentheses in SpaceBeforeParensOptions.
# ---------------------------------------
#>>>>>
 # SpaceBeforeParens: Custom


#` SpaceBeforeParensOptions (SpaceBeforeParensCustom) clang-format 14 ¶
# Control of individual space before parentheses.
# 
# If SpaceBeforeParens is set to Custom, use this to specify how each individual space before parentheses case should be handled. Otherwise, this is ignored.
# 
# # Example of usage:
# SpaceBeforeParens: Custom
# SpaceBeforeParensOptions:
#   AfterControlStatements: true
#   AfterFunctionDefinitionName: true
# Nested configuration flags:
# 
# Precise control over the spacing before parentheses.
# 
# # Should be declared this way:
# SpaceBeforeParens: Custom
# SpaceBeforeParensOptions:
#   AfterControlStatements: true
#   AfterFunctionDefinitionName: true
# ---------------------------------------

# bool AfterControlStatements If true, put space between control statement keywords (for/if/while…) and opening parentheses.
# 
# true:                                  false:
# if (...) {}                     vs.    if(...) {}
# ---------------------------------------

# bool AfterForeachMacros If true, put space between foreach macros and opening parentheses.
# 
# true:                                  false:
# FOREACH (...)                   vs.    FOREACH(...)
#   <loop-body>                            <loop-body>
# ---------------------------------------

# bool AfterFunctionDeclarationName If true, put a space between function declaration name and opening parentheses.
# 
# true:                                  false:
# void f ();                      vs.    void f();
# ---------------------------------------

# bool AfterFunctionDefinitionName If true, put a space between function definition name and opening parentheses.
# 
# true:                                  false:
# void f () {}                    vs.    void f() {}
# ---------------------------------------

# bool AfterIfMacros If true, put space between if macros and opening parentheses.
# 
# true:                                  false:
# IF (...)                        vs.    IF(...)
#   <conditional-body>                     <conditional-body>
# ---------------------------------------

# bool AfterOverloadedOperator If true, put a space between operator overloading and opening parentheses.
# 
# true:                                  false:
# void operator++ (int a);        vs.    void operator++(int a);
# object.operator++ (10);                object.operator++(10);
# ---------------------------------------

# bool AfterPlacementOperator If true, put a space between operator new/delete and opening parenthesis.
# 
# true:                                  false:
# new (buf) T;                    vs.    new(buf) T;
# delete (buf) T;                        delete(buf) T;
# ---------------------------------------

# bool AfterRequiresInClause If true, put space between requires keyword in a requires clause and opening parentheses, if there is one.
# 
# true:                                  false:
# template<typename T>            vs.    template<typename T>
# requires (A<T> && B<T>)                requires(A<T> && B<T>)
# ...                                    ...
# ---------------------------------------

# bool AfterRequiresInExpression If true, put space between requires keyword in a requires expression and opening parentheses.
# 
# true:                                  false:
# template<typename T>            vs.    template<typename T>
# concept C = requires (T t) {           concept C = requires(T t) {
#               ...                                    ...
#             }                                      }
# ---------------------------------------

# bool BeforeNonEmptyParentheses If true, put a space before opening parentheses only if the parentheses are not empty.
# 
# true:                                  false:
# void f (int a);                 vs.    void f();
# f (a);                                 f();
# ---------------------------------------
#>>>>>
SpaceBeforeParensOptions:
  AfterControlStatements: true
  AfterForeachMacros: true
  AfterFunctionDeclarationName: false
  AfterFunctionDefinitionName: false
  AfterIfMacros: true
  AfterOverloadedOperator: true
  AfterPlacementOperator: true
  AfterRequiresInClause: true
  AfterRequiresInExpression: true
  BeforeNonEmptyParentheses: false


#` SpaceBeforeRangeBasedForLoopColon (Boolean) clang-format 7 ¶
# If false, spaces will be removed before range-based for loop colon.
# 
# true:                                  false:
# for (auto v : values) {}       vs.     for(auto v: values) {}
# ---------------------------------------
#>>>>>
SpaceBeforeRangeBasedForLoopColon: false


#` SpaceBeforeSquareBrackets (Boolean) clang-format 10 ¶
# If true, spaces will be before [. Lambdas will not be affected. Only the first [ will get a space added.
# 
# true:                                  false:
# int a [5];                    vs.      int a[5];
# int a [5][5];                 vs.      int a[5][5];
# ---------------------------------------
#>>>>>
SpaceBeforeSquareBrackets: false


#` SpaceInEmptyBlock (Boolean) clang-format 10 ¶
# If true, spaces will be inserted into {}.
# 
# true:                                false:
# void f() { }                   vs.   void f() {}
# while (true) { }                     while (true) {}
# ---------------------------------------
#>>>>>
SpaceInEmptyBlock: false


#` SpaceInEmptyParentheses (Boolean) clang-format 3.7 ¶    !!!!!***NOT USED***  deprecated - See InEmptyParentheses of SpacesInParensOptions.
# If true, spaces may be inserted into (). This option is deprecated. See InEmptyParentheses of SpacesInParensOptions.
# ---------------------------------------
#>>>>>
 # SpaceInEmptyParentheses: 



#` SpacesBeforeTrailingComments (Unsigned) clang-format 3.7 ¶
# The number of spaces before trailing line comments (// - comments).
# 
# This does not affect trailing block comments (/* - comments) as those commonly have different usage patterns and a number of special cases. In the case of Verilog, it doesn’t affect a comment right after the opening parenthesis in the port or parameter list in a module header, because it is probably for the port on the following line instead of the parenthesis it follows.
# 
# SpacesBeforeTrailingComments: 3
# void f() {
#   if (true) {   // foo1
#     f();        // bar
#   }             // foo
# }
# ---------------------------------------
#>>>>>
SpacesBeforeTrailingComments: 2


#` SpacesInAngles (SpacesInAnglesStyle) clang-format 3.4 ¶
# The SpacesInAnglesStyle to use for template argument lists.
# ---------------------------------------

# SIAS_Never (in configuration: Never) Remove spaces after < and before >.
# 
# static_cast<int>(arg);
# std::function<void(int)> fct;
# ---------------------------------------

# SIAS_Always (in configuration: Always) Add spaces after < and before >.
# 
# static_cast< int >(arg);
# std::function< void(int) > fct;
# ---------------------------------------

# SIAS_Leave (in configuration: Leave) Keep a single space after < and before > if any spaces were present. Option Standard: Cpp03 takes precedence.
# ---------------------------------------
#>>>>>
SpacesInAngles: Never


#` SpacesInCStyleCastParentheses (Boolean) clang-format 3.7 ¶    !!!!!***NOT USED***  deprecated - See InCStyleCasts of SpacesInParensOptions.
# If true, spaces may be inserted into C style casts. This option is deprecated. See InCStyleCasts of SpacesInParensOptions.
# ---------------------------------------
#>>>>>
 # SpacesInCStyleCastParentheses: 


#` SpacesInConditionalStatement (Boolean) clang-format 10 ¶    !!!!!***NOT USED***  deprecated - See InConditionalStatements of SpacesInParensOptions.
# If true, spaces will be inserted around if/for/switch/while conditions. This option is deprecated. See InConditionalStatements of SpacesInParensOptions.
# ---------------------------------------
#>>>>>
 # SpacesInCStyleCastParentheses: 


#` SpacesInContainerLiterals (Boolean) clang-format 3.7 ¶
# If true, spaces are inserted inside container literals (e.g. ObjC and Javascript array and dict literals). For JSON, use SpaceBeforeJsonColon instead.
# 
# true:                                  false:
# var arr = [ 1, 2, 3 ];         vs.     var arr = [1, 2, 3];
# f({a : 1, b : 2, c : 3});              f({a: 1, b: 2, c: 3});
# ---------------------------------------
#>>>>>
SpacesInContainerLiterals: true


#` SpacesInLineCommentPrefix (SpacesInLineComment) clang-format 13 ¶
# How many spaces are allowed at the start of a line comment. To disable the maximum set it to -1, apart from that the maximum takes precedence over the minimum.
# 
# Minimum = 1
# Maximum = -1
# // One space is forced
# 
# //  but more spaces are possible
# 
# Minimum = 0
# Maximum = 0
# //Forces to start every comment directly after the slashes
# Note that in line comment sections the relative indent of the subsequent lines is kept, that means the following:
# 
# before:                                   after:
# Minimum: 1
# //if (b) {                                // if (b) {
# //  return true;                          //   return true;
# //}                                       // }
# 
# Maximum: 0
# /// List:                                 ///List:
# ///  - Foo                                /// - Foo
# ///    - Bar                              ///   - Bar
# This option has only effect if ReflowComments is set to true.
# ---------------------------------------

# Nested configuration flags:
# 
# Control of spaces within a single line comment.
# 
# unsigned Minimum The minimum number of spaces at the start of the comment.
# 
# unsigned Maximum The maximum number of spaces at the start of the comment.
# ---------------------------------------
#>>>>>
SpacesInLineCommentPrefix: 
  Maximum: 1


#` SpacesInParens (SpacesInParensStyle) clang-format 17 ¶
# Defines in which cases spaces will be inserted after ( and before ).
# ---------------------------------------

# SIPO_Never (in configuration: Never) Never put a space in parentheses.
# 
# void f() {
#   if(true) {
#     f();
#   }
# }
# ---------------------------------------

# SIPO_Custom (in configuration: Custom) Configure each individual space in parentheses in SpacesInParensOptions.
# ---------------------------------------
#>>>>>
SpacesInParens: Custom


#` SpacesInParensOptions (SpacesInParensCustom) clang-format 17 ¶
# Control of individual spaces in parentheses.
# 
# If SpacesInParens is set to Custom, use this to specify how each individual space in parentheses case should be handled. Otherwise, this is ignored.
# 
# # Example of usage:
# SpacesInParens: Custom
# SpacesInParensOptions:
#   ExceptDoubleParentheses: false
#   InConditionalStatements: true
#   InEmptyParentheses: true
# Nested configuration flags:
# 
# Precise control over the spacing in parentheses.
# 
# # Should be declared this way:
# SpacesInParens: Custom
# SpacesInParensOptions:
#   ExceptDoubleParentheses: false
#   InConditionalStatements: true
#   Other: true
# ---------------------------------------

# bool ExceptDoubleParentheses Override any of the following options to prevent addition of space when both opening and closing parentheses use multiple parentheses.
# 
#  true:
#  __attribute__(( noreturn ))
#  __decltype__(( x ))
#  if (( a = b ))
# false:
#   Uses the applicable option.
# ---------------------------------------

# bool InConditionalStatements Put a space in parentheses only inside conditional statements (for/if/while/switch...).
# 
# true:                                  false:
# if ( a )  { ... }              vs.     if (a) { ... }
# while ( i < 5 )  { ... }               while (i < 5) { ... }
# ---------------------------------------

# bool InCStyleCasts Put a space in C style casts.
# 
# true:                                  false:
# x = ( int32 )y                  vs.    x = (int32)y
# y = (( int (*)(int) )foo)(x);          y = ((int (*)(int))foo)(x);
# ---------------------------------------

# bool InEmptyParentheses Insert a space in empty parentheses, i.e. ().
# 
# true:                                false:
# void f( ) {                    vs.   void f() {
#   int x[] = {foo( ), bar( )};          int x[] = {foo(), bar()};
#   if (true) {                          if (true) {
#     f( );                                f();
#   }                                    }
# }                                    }
# ---------------------------------------

# bool Other Put a space in parentheses not covered by preceding options.
# 
# true:                                 false:
# t f( Deleted & ) & = delete;    vs.   t f(Deleted &) & = delete;
# ---------------------------------------
#>>>>>
 # !_NOTE_! To achieve the more readable ACFS behavior in nested conditional expression parentheses of control statements, do the following:
#   SpacesInParens: Custom
#   SpacesInParensOptions:
#     InConditionalStatements: true
#  However, this does not provide the same behavior for nested parentheses in function definitions and function call statements.
SpacesInParensOptions: 
  ExceptDoubleParentheses: false
  InConditionalStatements: true
  InCStyleCasts: false
  InEmptyParentheses: false
# The next option affects space between braces and the contents of the braces in the initialization of arrays  
#   but it also affect space between parentheses in conditional statements like if and while, even though the InConditionalStatements: setting should prevent this.
#  Other: true


#` SpacesInParentheses (Boolean) clang-format 3.7 ¶    !!!!!***NOT USED***  deprecated - See next line for info
# If true, spaces will be inserted after ( and before ). This option is deprecated. The previous behavior is preserved by using SpacesInParens with Custom and by setting all SpacesInParensOptions to true except for InCStyleCasts and InEmptyParentheses.
# ---------------------------------------
#>>>>>
 # SpacesInParentheses: 


#` SpacesInSquareBrackets (Boolean) clang-format 3.7 ¶
# If true, spaces will be inserted after [ and before ]. Lambdas without arguments or unspecified size array declarations will not be affected.
# 
# true:                                  false:
# int a[ 5 ];                    vs.     int a[5];
# std::unique_ptr<int[]> foo() {} // Won't be affected
# ---------------------------------------
#>>>>>
SpacesInSquareBrackets: false


#` Standard (LanguageStandard) clang-format 3.7 ¶    !!!!!$$$---SPECIFIED AT THE TOP OF THIS FILE---$$$
# Parse and format C++ constructs compatible with this standard.
# 
# c++03:                                 latest:
# vector<set<int> > x;           vs.     vector<set<int>> x;
# ---------------------------------------

# LS_Cpp03 (in configuration: c++03) Parse and format as C++03. Cpp03 is a deprecated alias for c++03
# LS_Cpp11 (in configuration: c++11) Parse and format as C++11.
# LS_Cpp14 (in configuration: c++14) Parse and format as C++14.
# LS_Cpp17 (in configuration: c++17) Parse and format as C++17.
# LS_Cpp20 (in configuration: c++20) Parse and format as C++20.
# LS_Latest (in configuration: Latest) Parse and format using the latest supported language version. Cpp11 is a deprecated alias for Latest
# LS_Auto (in configuration: Auto) Automatic detection based on the input.
# ---------------------------------------
#>>>>>
 # Standard: 


#` StatementAttributeLikeMacros (List of Strings) clang-format 12 ¶    !!!!!***NOT USED***  (List of Strings) 
# Macros which are ignored in front of a statement, as if they were an attribute. So that they are not parsed as identifier, for example for Qts emit.
# 
# AlignConsecutiveDeclarations: true
# StatementAttributeLikeMacros: []
# unsigned char data = 'x';
# emit          signal(data); // This is parsed as variable declaration.
# 
# AlignConsecutiveDeclarations: true
# StatementAttributeLikeMacros: [emit]
# unsigned char data = 'x';
# emit signal(data); // Now it's fine again.
# ---------------------------------------
#>>>>>
 # StatementAttributeLikeMacros: 


#` StatementMacros (List of Strings) clang-format 8 ¶    !!!!!***NOT USED***  (List of Strings) 
# A vector of macros that should be interpreted as complete statements.
# 
# Typical macros are expressions and require a semicolon to be added. Sometimes this is not the case, and this allows to make clang-format aware of such cases.
# 
# For example: Q_UNUSED
# ---------------------------------------
#>>>>>
 # StatementMacros: 


#` TabWidth (Unsigned) clang-format 3.7 ¶    !!!!!$$$---SPECIFIED AT THE TOP OF THIS FILE---$$$
# The number of columns used for tab stops.
# ---------------------------------------
#>>>>>
 # TabWidth: 


#` TableGenBreakInsideDAGArg (DAGArgStyle) clang-format 19 ¶
# The styles of the line break inside the DAGArg in TableGen.
# ---------------------------------------

# DAS_DontBreak (in configuration: DontBreak) Never break inside DAGArg.
# 
# let DAGArgIns = (ins i32:$src1, i32:$src2);
# ---------------------------------------

# DAS_BreakElements (in configuration: BreakElements) Break inside DAGArg after each list element but for the last. This aligns to the first element.
# 
# let DAGArgIns = (ins i32:$src1,
#                      i32:$src2);
# ---------------------------------------

# DAS_BreakAll (in configuration: BreakAll) Break inside DAGArg after the operator and the all elements.
# 
# let DAGArgIns = (ins
#     i32:$src1,
#     i32:$src2
# );
# ---------------------------------------
#>>>>>
TableGenBreakInsideDAGArg: DontBreak


#` TableGenBreakingDAGArgOperators (List of Strings) clang-format 19 ¶    !!!!!***NOT USED***  (List of Strings)
# Works only when TableGenBreakInsideDAGArg is not DontBreak. The string list needs to consist of identifiers in TableGen. If any identifier is specified, this limits the line breaks by TableGenBreakInsideDAGArg option only on DAGArg values beginning with the specified identifiers.
# 
# For example the configuration,
# 
# TableGenBreakInsideDAGArg: BreakAll
# TableGenBreakingDAGArgOperators: [ins, outs]
# makes the line break only occurs inside DAGArgs beginning with the specified identifiers ins and outs.
# 
# let DAGArgIns = (ins
#     i32:$src1,
#     i32:$src2
# );
# let DAGArgOtherID = (other i32:$other1, i32:$other2);
# let DAGArgBang = (!cast<SomeType>("Some") i32:$src1, i32:$src2)
# ---------------------------------------
#>>>>>
 # TableGenBreakingDAGArgOperators: 


#` TemplateNames (List of Strings) clang-format 20 ¶    !!!!!***NOT USED***  beyond clang-format 19
# A vector of non-keyword identifiers that should be interpreted as template names.
# 
# A < after a template name is annotated as a template opener instead of a binary operator.
# ---------------------------------------
#>>>>>
 # TemplateNames: 


#` TypeNames (List of Strings) clang-format 17 ¶    !!!!!***NOT USED***  (List of Strings)
# A vector of non-keyword identifiers that should be interpreted as type names.
# 
# A *, &, or && between a type name and another non-keyword identifier is annotated as a pointer or reference token instead of a binary operator.
# ---------------------------------------
#>>>>>
 # TypeNames: 


#` TypenameMacros (List of Strings) clang-format 9 ¶    !!!!!***NOT USED***  (List of Strings)
# A vector of macros that should be interpreted as type declarations instead of as function calls.
# 
# These are expected to be macros of the form:
# 
# STACK_OF(...)
# In the .clang-format configuration file, this can be configured like:
# 
# TypenameMacros: [STACK_OF, LIST]
# For example: OpenSSL STACK_OF, BSD LIST_ENTRY.
# ---------------------------------------
#>>>>>
 # TypenameMacros: 


#` UseCRLF (Boolean) clang-format 10 ¶    !!!!!***NOT USED***  deprecated - See LF and CRLF of LineEnding.
# This option is deprecated. See LF and CRLF of LineEnding.
# ---------------------------------------
#>>>>>
 # UseCRLF: 


#` UseTab (UseTabStyle) clang-format 3.7 ¶    !!!!!$$$---SPECIFIED AT THE TOP OF THIS FILE---$$$
# The way to use tab characters in the resulting file.
# ---------------------------------------

# UT_Never (in configuration: Never) Never use tab.
# UT_ForIndentation (in configuration: ForIndentation) Use tabs only for indentation.
# UT_ForContinuationAndIndentation (in configuration: ForContinuationAndIndentation) Fill all leading whitespace with tabs, and use spaces for alignment that appears within a line (e.g. consecutive assignments and declarations).
# UT_AlignWithSpaces (in configuration: AlignWithSpaces) Use tabs for line continuation and indentation, and spaces for alignment.
# UT_Always (in configuration: Always) Use tabs whenever we need to fill whitespace that spans at least from one tab stop to the next one.
# ---------------------------------------
#>>>>>
 # UseTab: 


#` VariableTemplates (List of Strings) clang-format 20 ¶    !!!!!***NOT USED***  beyond clang-format 19
# A vector of non-keyword identifiers that should be interpreted as variable template names.
# 
# A ) after a variable template instantiation is not annotated as the closing parenthesis of C-style cast operator.
# ---------------------------------------
#>>>>>
 # VariableTemplates: 


#` VerilogBreakBetweenInstancePorts (Boolean) clang-format 17 ¶    !!!!!***NOT USED***  For Verilog only
# For Verilog, put each port on its own line in module instantiations.
# 
# true:
# ffnand ff1(.q(),
#            .qbar(out1),
#            .clear(in1),
#            .preset(in2));
# 
# false:
# ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));
# ---------------------------------------
#>>>>>
 # VerilogBreakBetweenInstancePorts: 


#` WhitespaceSensitiveMacros (List of Strings) clang-format 11 ¶    !!!!!***NOT USED***  (List of Strings)
# A vector of macros which are whitespace-sensitive and should not be touched.
# 
# These are expected to be macros of the form:
# 
# STRINGIZE(...)
# In the .clang-format configuration file, this can be configured like:
# 
# WhitespaceSensitiveMacros: [STRINGIZE, PP_STRINGIZE]
# For example: BOOST_PP_STRINGIZE
# ---------------------------------------
#>>>>>
 # WhitespaceSensitiveMacros: 


#` WrapNamespaceBodyWithEmptyLines (WrapNamespaceBodyWithEmptyLinesStyle) clang-format 20 ¶    !!!!!***NOT USED***  beyond clang-format 19
# Wrap namespace body with empty lines.
# ---------------------------------------

# WNBWELS_Never (in configuration: Never) Remove all empty lines at the beginning and the end of namespace body.
# 
# namespace N1 {
# namespace N2
# function();
# }
# }
# ---------------------------------------

# WNBWELS_Always (in configuration: Always) Always have at least one empty line at the beginning and the end of namespace body except that the number of empty lines between consecutive nested namespace definitions is not increased.
# 
# namespace N1 {
# namespace N2 {
# 
# function();
# 
# }
# }
# ---------------------------------------

# WNBWELS_Leave (in configuration: Leave) Keep existing newlines at the beginning and the end of namespace body. MaxEmptyLinesToKeep still applies.
# ---------------------------------------
#>>>>>
 # WrapNamespaceBodyWithEmptyLines: Always





#` Keep the following items which are used with the Notepad++ User Defined Language (UDL v2.0 format) file
# !!!!! five bang marks in this Notepad++ UDL (User Defined Language) means stop the comment and begin formatting UDL keywords.
# !!!!!---Bookmark---  
 # !!!!! !_NOTE_! 
#    !!!!!<<<---IMPORTANT--->>>
#    !!!!!***NOT USED***  deprecated - See XXXX
#    !!!!!***NOT USED***  This is actually incorrect.         Note:  After the incorrect option description is the corrected version.
#    !!!!!***NOT USED***  beyond clang-format 19
#    !!!!!$$$---SPECIFIED AT THE TOP OF THIS FILE---$$$
# ---------------------------------------
#>>>>>